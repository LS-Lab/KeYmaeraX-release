# Syntax for Tactics (Bellerophon)

In KeYmaera X, we can write programs to do proofs for us, called tactics.
KeYmaera X will also generate a tactic for you any time you do a proof step,
so for beginners we recommend reading and copy/pasting tactics produced by
KeYmaera X before writing your own.

Syntax for tactics:

```  
TAC ::= builtin(ARGS)
       | TAC; TAC 
       | "TAC | TAC" 
       | ?TAC
       | (TAC)* 
       | <(TAC, ..., TAC) 
       | <("LABEL_1": TAC, ..., "LABEL_n": TAC)
       | TAC using LIST
       | nil
```

* `builtin(ARGS)`
  Builtin tactics do all the hard work, the other kinds of tactics just combine
  builtin tactics. These include all the sequent calculus and hybrid program rules.

    * Some builtin tactics, such as `auto` and `QE`, work on the entire sequent and so don't need any arguments.

    * `expand("NAME")` and `expandAllDefs` expand definitions

    * Most builtins take exactly one argument telling you what formula to use it on (a locator).
      Conclusions are positive numbers, starting with 1. Assumptions are negative numbers, starting with -1.
      If you want to work on a subformula, you can use dot notation to specify the subformula.
      For example if you have `((A & B) -> C)` as formula 1, then `1.0` is `(A & B)`, `1.0.0` is `A`, `1.0.1` is `B`
      and `1.1` is `C`.
      There are other notations to specify a locator.
      See below a detailed example on how to specify the location on which to apply the formula.

    * A few tactics like `allL` and `loop` take a term or formula as an argument. When you pass a formula or term
      to a tactic as an argument, you enclose it in double quotes, e.g. we could call loop like `loop("x > 0", 1)`.

* `TAC1; TAC2`  Runs `TAC1` first and then `TAC2`, but only if `TAC1` succeeds

* `TAC1 | TAC2` Runs `TAC1` first and if it fails, it tries `TAC2` instead.
  This is really useful when you want to write some reusable proof search program
  (e.g. your own custom version of `auto`), but is less often used if you're just
  trying to do one specific proof about one specific model.

* `?TAC` tries running `TAC`, and if `TAC` fails, it ignores the failure and succeeds but does nothing.
  This is useful in search programs if there's some step that might not work all the time.

* `(TAC)*` runs `TAC` over and over again until it can't run `TAC` any more.
  This is useful when writing proof search programs and also useful
  for repeating simple repetitive proof steps.
  For example, if you have a bunch of &s in your assumptions that you
  want to break apart, you could do something like `(andL('L)*)`

* `<(TAC1, ..., TACN)`  Runs each tactic `TAC_i` on the i'th subgoal.
  It fails immediately if there are not exactly i subgoals.
  You will typically see this immediately after some tactic that causes the
  proof to branch, such as `andR` or `orL` --- most tactics assume they are working
  on an individual subgoal and so will not work after an `andR` or `orL` without branching.

* `<("LABEL_1": TAC1, ..., "LABEL_N": TACN)` Runs each tactic `TAC_i` on the subgoal with label `LABEL_i`.

* `TAC using LIST` Runs tactic `TAC` on a sequent that includes only formulas from `LIST` of
  formulas `fml_1 :: ... :: fml_n :: nil`.

* `nil` is a builtin tactic that does absolutely nothing, but succeeds.
  This is used a lot in the tactics autogenerated by KeYmaera X any time the syntax
  says it has to write down a tactic but it doesn't want to do anything.
  For example if you call a branching tactic but only do work on the first branch, the remaining
  branches will have the `nil` tactic.

## A detailed example on locators

Locators are a way of indicating a specific part of a sequent to a tactic.
Usually, it corresponds to where the tactic should be applied.

We use `⊢ 1: x=0 ∨ (y=1->[?x≠0;x:=y+1;](x=2∧true))` as an example of sequent to derive. The `1:` corresponds to the UI
stating that it is the first conclusion.

First, we want to use the tactic `orR` to split the formula in two:

```
 G |- D, p, q
--------------- (|R Or right)
 G |- p|q, D
```

Here is a list of tactics that do exactly this, using different way of specifying where to apply it.

- `orR(1)`
- `orR(1=="x=0|(y=1->[?x!=0;x:=y+1;](x=2&true))")`
- `orR(1~="x=0|p()")`
- `orR('Rlast)`
- `orR('R)`
- `orR('R=="x=0|(y=1->[?x!=0;x:=y+1;](x=2&true))")`
- `orR('R~="x=0|q()")`

The first four indicate the exact position of the formula in the list (`'Rlast` represents the last succedent).
When using integer position (e.g. 1), it is possible to give the exact or approximate shape of the formula
(using `==` or `~=` respectively), which serves as an additional guarantee that the tactic does what you want it to do.
The shape can be any valid dL expression.

The last three do not specify the position, but rather will look for the first formula in the succedent that corresponds
and for which the tactic is applicable. Here, describing the exact or approximate formula is strongly recommended as
there could be multiple formulas where your tactic is applicable.
Approximations do not check for admissibility in the uniform substitution sense, e.g. `[x:=2;]p()` matches `[x:=2;]x=2`.
For antecedents, the numbers are negative, and there are `'Llast` and `'L`.

Now we have the following goal: `⊢ 1: x=0, 2: y=1->[?x≠0;x:=y+1;](x=2∧true)`.
We could try to simplify the conjunction using `andTrue: p ∧ true ↔ p`. This time, we must also specify where to apply
the tactic *within* the formula. Here are the ways to do so:

- `andTrue(2.1.1)`
- `andTrue(2=="y=1->[?x!=0;x:=y+1;](#x=2&true#)")`
- `andTrue(2.1.1=="x=2&true")`
- `andTrue(2.1.1=="y=1->[?x!=0;x:=y+1;](#x=2&true#)")`
- `andTrue(2~="p()->[a;](#q()&true#)")`
- `andTrue('Rlast.1.1)`
- `andTrue('R=="y=1->[?x!=0;x:=y+1;](#x=2&true#)")`
- `andTrue('R~="p()->[a;](#q()&true#)")`

To navigate within the formula, we can use .0 (resp. .1) to select the only/left (resp. right) branch. It is also
possible to use `#...#` to isolate the subformula when indices become tricky. In the fourth case, both versions are
given (and KeYmaera X checks whether they correspond). The tactic `andTrue('R)` would not work here as it only checks
the top level formula, not the subformulas.

Indices are dependent on the implementation, especially regarding the order of succedents/antecedents. So in the web
app, KeYmaera X always transforms indices into their `'R=="..."` equivalent. The last version (using approximation
without indices) is probably the most stable/readable when written by users.

(And press `auto` if you want to finish the proof.)

# References

1. Nathan Fulton, Stefan Mitsch, Brandon Bohrer and André Platzer.
   [Bellerophon: Tactical theorem proving for hybrid systems](https://doi.org/10.1007/978-3-319-66107-0_14).
   Theorem Proving, International Conference, ITP 2017, volume 10499 of LNCS, pp. 207-224. Springer, 2017.