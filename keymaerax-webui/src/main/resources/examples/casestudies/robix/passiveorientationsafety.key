Functions.
	R ep.			 		/* time limit for control decisions */
 	R b().					/* minimum braking capability of the robot */
	R A.					/* maximum acceleration -b() <= a <= A */
	R Om.					/* max. rotational velocity for dynamic window */
	R V(). 				/* Maximum velocity of obstacle */
	R alpha(). 			/* Sensor range  in radian*/
End.

ProgramVariables.
	R x.		/* robot position: x */
	R y.		/* robot position: y */
	R v.		/* robot translational velocity */
	R a.		/* robot translational acceleration */
	R w.		/* robot rotational velocity */
	R dx. 		/* robot orientation: x */
	R dy. 		/* robot orientation: y */
	R r.		/* radius of curve */
	R t.		/* clock variable */
	R ox. 				/* position summary of obstacle */
  R oy.
  R odx. 				/* direction and linear velocity of obstacle */
  R ody.
  /* Ghost variables: Capture the state of v,x,y before continuous evolution. Can later be replaced by \old */
	/*R vS.
	R xS.
	R yS.
	R TS.
	R oxS.
  R oyS.*/
	R isVisible. /* Indicates whether or not the obstacle is visible for the robot (>=0) when it makes its decision. */
	R talpha. /* Angle that the robot traveled since he last chose a new curve */
End.

Problem.
	  v >= 0
	& V() >= 0
	& ( ( (x-ox >= 0 -> x-ox > v^2 / (2*b()) + V()*(v/b()))
      & (x-ox <= 0 -> ox-x > v^2 / (2*b()) + V()*(v/b())))
    | ( (y-oy >= 0 -> y-oy > v^2 / (2*b()) + V()*(v/b()))
      & (y-oy <= 0 -> oy-y > v^2 / (2*b()) + V()*(v/b()))))
 	& (r < 0 -> v^2/(2*b()*(-r)) < alpha())
 	& (r >= 0 -> v^2/(2*b()*r) < alpha())
 	& talpha = 0
	& r != 0
	& dx^2 + dy^2 = 1
	& A >= 0
	& b() > 0
	& ep > 0
	& alpha() > 0 /* implied by conditions above, just to be sure */
      -> [
      {
          {
           /* control obstacle */
           odx :=*;
           ody :=*;
           ?odx^2+ody^2 <= V()^2;

           /* control robot */
           {
           /* brake on current curve. If the velocity is zero this just means that the robot remains stopped */
           {a := -b();}
        ++ /* When we are standing, we can negate direction (switch = -1) or leave it unchanged (switch = 1) */
           {?v=0; a:=0; dx:=-dx; dy:=-dy;}
        ++ /* or choose a new safe curve */
				   {a :=*; ?-b() <= a & a <= A;
            r :=*; ?r != 0; /* do not spin */

            /* measure obstacle position and whether or not it is visible to the robot */
            ox :=*; oy :=*; isVisible :=*;

						{
            /* if(v+a*ep < 0) then */
            { ?v+a*ep < 0;
						  /* Case 1: Braking finished before ep */
						  /* use that curve, if it is a safe one (admissible velocities), only consider obstacles in front */
						  /* Note: a <0 is ensured by v+a*ep < 0 & v >= 0 & ep  > 0 */
						  ?(isVisible >= 0 -> ( (  (x-ox >= 0 -> x - ox > v^2/(-2*a) + (v/(-a)) * V())
						                        & (x-ox <= 0 -> ox - x > v^2/(-2*a) + (v/(-a)) * V()))
						                     | (  (y-oy >= 0 -> y - oy > v^2/(-2*a) + (v/(-a)) * V())
						                        & (y-oy <= 0 -> oy - y > v^2/(-2*a) + (v/(-a)) * V())) ) );
						  ?(r >= 0 -> v^2/(-2*a) < alpha()*r) & (r < 0 -> v^2/(-2*a) < -alpha()*r);}
						/* else */
					++{ ?v+a*ep >= 0;
						  /* Case 2: Velocity is guaranteed positive after continuous evolution (or becomes zero exactly at the end) */
						  /* use that curve, if it is a safe one (admissible velocities), only consider obstacles in front */
						  ?(isVisible >=0 -> ( ( (x-ox >= 0 -> x-ox > v^2/(2*b()) + V()*v/b() + (a/b() + 1) * (a/2 * ep^2 + ep*(v+V())))
                                   & (x-ox <= 0 -> ox-x > v^2/(2*b()) + V()*v/b() + (a/b() + 1) * (a/2 * ep^2 + ep*(v+V()))))
                                 | ( (y-oy >= 0 -> y-oy > v^2/(2*b()) + V()*v/b() + (a/b() + 1) * (a/2 * ep^2 + ep*(v+V())))
                                   & (y-oy <= 0 -> oy-y > v^2/(2*b()) + V()*v/b() + (a/b() + 1) * (a/2 * ep^2 + ep*(v+V()))))) );
						  ?(r >= 0 -> v^2/(2*b()) + (a/b() + 1) * (a/2 * ep^2 + ep*v) < alpha()*r) & (r < 0 -> v^2/(2*b()) + (a/b() + 1) * (a/2 * ep^2 + ep*v) < -alpha()*r); }
						}
						talpha := 0;
				  }
				  }

				/* Reset the clocks */
				t := 0;
				/* Set w according to physics (rigid body motion) */
				w :=*; ?w*r = v;

				/* TODO do in proof, not in model (Save the state before the continuous evolution (Ghosts))*/
				/*vS := v;
				xS := x;
				yS := y;
				TS := talpha;
				oxS := ox;
				oyS := oy;*/
				}

				{x' = v * dx, y' = v * dy, dx' = -w * dy, dy' = w * dx, v' = a, w' = a/r, talpha'=w,
        							ox' = odx, oy' = ody, t' = 1 & (t <= ep & v >= 0)}
						/*
						 * @invariant(
						  vS >= 0  & dx^2 + dy^2 = 1 & r != 0 & A >= 0 & b() >  0 & \forall O i.  V(i) >= 0 & ep >  0 & t >= 0 &
						  \forall O i.(odx(i)^2 + ody(i)^2 <= V(i)^2)

						   v = vS + a * t & -t * (v - a / 2 * t) <= x - xS & x - xS <= t * (v - a / 2 * t)
                	        & -t * (v - a / 2 * t) <= y - yS
                    	  	& y - yS <= t * (v - a / 2 * t)
                    		& \forall O i.
                        	(  -t * V(i) <= ox(i) - oxS(i) & ox(i) - oxS(i) <= t * V(i) & -t * V(i) <= oy(i) - oyS(i)
                        	& oy(i) - oyS(i) <= t * V(i))
                        	& w = a/r*t + vS / r

							(talpha-TS) = a/(2*r) * t^2 + vS/r * t

							Case 1:
              			  a = -b() &  (vS = 0
               			  | TS + vS^2/(2*b()*r) < alpha  & TS + vS^2/(2*b()*(-r)) < alpha  & -TS + vS^2/(2*b()*r) < alpha   & -TS + vS^2/(2*b()*(-r)) < alpha & \forall O i. (Back(i) >=0 ->
                   		 ( xS - oxS(i) >  vS^2 / (2 * b()) + V(i) * vS / b() | oxS(i) - xS >  vS^2 / (2 * b()) + V(i) * vS / b()
                    	 | yS - oyS(i) >  vS^2 / (2 * b()) + V(i) * vS / b() | oyS(i) - yS >  vS^2 / (2 * b()) + V(i) * vS / b())))

                    	 Case 3:
             	           -b() <= a
              				& a <= A
              				& vS + a * ep <  0 & TS = 0
              				 & TS + vS^2/(2*(-a)*r) < alpha  & TS + vS^2/(2*(-a)*(-r)) < alpha  & -TS + vS^2/(2*(-a)*r) < alpha   & -TS + vS^2/(2*(-a)*(-r)) < alpha

              				 \forall O i. (Back(i) >=0 ->
               				 (  xS - oxS(i) >  vS^2 / (-2 * a) + vS / -a * V(i) | oxS(i) - xS >  vS^2 / (-2 * a) + vS / -a * V(i)
                 				| yS - oyS(i) >  vS^2 / (-2 * a) + vS / -a * V(i) | oyS(i) - yS >  vS^2 / (-2 * a) + vS / -a * V(i)))
              				Case 4:
              				-b() <= a
              				& a <= A
              				& vS + a * ep >=  0 & TS = 0
							& (vS^2/(2*b()) + (a/b() + 1) * (a/2 * (ep)^2 + (ep)*vS))/r < alpha & (vS^2/(2*b()) + (a/b() + 1) * (a/2 * (ep)^2 + (ep)*vS))/(-r) < alpha

              				 \forall O i. (Back(i) >=0 ->
  							 ( xS - oxS(i) >  vS^2 / (2 * b()) + (a / b() + 1) * (a / 2 * (ep)^2 + ep * vS) + V(i) * (ep + (vS + a * ep) / b())
  							 | oxS(i) - xS >  vS^2 / (2 * b()) + (a / b() + 1) * (a / 2 * (ep)^2 + ep * vS) + V(i) * (ep + (vS + a * ep) / b())
    						 | yS - oyS(i) >  vS^2 / (2 * b()) + (a / b() + 1) * (a / 2 * (ep)^2 + ep * vS) + V(i) * (ep + (vS + a * ep) / b())
    						 | oyS(i) - yS >  vS^2 / (2 * b()) + (a / b() + 1) * (a / 2 * (ep)^2 + ep * vS) + V(i) * (ep + (vS + a * ep) / b())))
						) */
			}*
			 /*@invariant(v >= 0
				& dx^2+dy^2 = 1
				& r != 0
				& (v = 0 |
            (((talpha >= 0 & r >= 0 -> talpha + v^2/(2*b()*r) < alpha()) &
              (talpha >= 0 & r < 0 -> talpha + v^2/(-2*b()*r) < alpha()) &
              (talpha < 0 & r >= 0 -> -talpha + v^2/(2*b()*r) < alpha()) &
              (talpha < 0 & r < 0 -> -talpha + v^2/(-2*b()*r) < alpha()))
             &
             (isVisible < 0 |
              ( (x-ox >= 0 -> x-ox > v^2 / (2*b()) + V()*(v/b()))
              & (x-ox <= 0 -> ox-x > v^2 / (2*b()) + V()*(v/b()))) |
              ( (y-oy >= 0 -> y-oy > v^2 / (2*b()) + V()*(v/b()))
              & (y-oy <= 0 -> oy-y > v^2 / (2*b()) + V()*(v/b()))))
            )
				  )
       	)*/
		] (v = 0 | (x - ox)^2 + (y - oy)^2 > 0 | (isVisible < 0 & (talpha >= 0 -> talpha < alpha()) & (talpha < 0 -> -talpha < alpha())) )
End.

