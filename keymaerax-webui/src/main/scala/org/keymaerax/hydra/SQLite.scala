/*
 * Copyright (c) Carnegie Mellon University, Karlsruhe Institute of Technology.
 * See LICENSE.txt for the conditions of this license.
 */

/** @note Code Review 2016-08-02 LemmaDB aspects only */
package org.keymaerax.hydra

import org.keymaerax.bellerophon.BelleExpr
import org.keymaerax.bellerophon.parser.BellePrettyPrinter
import org.keymaerax.core._
import org.keymaerax.info.VersionNumber
import org.keymaerax.lemma._
import org.keymaerax.parser.{ArchiveParser, Parser}
import org.keymaerax.pt.ProvableSig
import org.keymaerax.tools.ToolEvidence
import org.sqlite.SQLiteConfig.{JournalMode, SynchronousMode}
import org.sqlite.{SQLiteConfig, SQLiteDataSource}
import slick.jdbc
import slick.jdbc.SQLiteProfile
import slick.jdbc.SQLiteProfile.api._
import slick.jdbc.SQLiteProfile.backend.Session

import java.io.FileOutputStream
import java.nio.channels.Channels
import scala.concurrent.Await
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.util.Try
import scala.util.matching.Regex

/**
 * Database implementation based on SQLite and Slick. Stores and queries:
 *   - Lemmas (used for storing proof steps)
 *   - UI configuration
 *   - Users
 *   - Models
 *   - Proofs and proof steps
 *   - Proof agendas
 *   - Proof trees
 *
 * @author
 *   nfulton
 * @author
 *   Joscha Mennicken
 */
object SQLite {

  import Tables._

  /** Production database. */
  lazy val ProdDB: SQLiteDB = new SQLiteDB(DBAbstractionObj.dblocation)

  /** Use this for all unit tests that work with the database, so tests don't infect the production database */
  lazy val TestDB: SQLiteDB = new SQLiteDB(DBAbstractionObj.testLocation)

  private val RULENAME_BRANCH_SEPARATOR: String = "@@"

  def versionOf(db: SQLiteDB): VersionNumber = VersionNumber.parse(db.getConfiguration("version").config("version"))

  /** Stores lemmas in the Lemma table of the given database. */
  class UncachedSQLiteLemmaDB(db: SQLiteDB) extends LemmaDBBase {

    /** @inheritdoc */
    final override def contains(lemmaID: LemmaID): Boolean = db.containsLemma(lemmaID.toInt)

    /** @inheritdoc */
    final override def readLemmas(ids: List[LemmaID]): Option[List[String]] = {
      val lemmaIds = ids.map(_.toInt)
      val lemmas = db.getLemmas(lemmaIds)
      assert(
        lemmas.isEmpty || lemmas.get.map(_._1) == lemmaIds,
        "Expected lemmas to be returned in requested order, but got\n" + lemmas.get.map(_._1).mkString(",") +
          " instead of\n" + lemmaIds.mkString(","),
      )
      lemmas.map(_.map(_._2))
    }

    /** @inheritdoc */
    final override def writeLemma(id: LemmaID, lemma: String): Unit = {
      if (db.containsLemma(id.toInt)) db.updateLemma(id.toInt, lemma)
      else {
        val createdId = db.createLemma()
        assert(
          createdId.toInt == id.toInt,
          s"Cannot create a new lemma with a custom ID unless that ID happens to be the next one generated by the SQLite database (requested: $id; created: $createdId)",
        )
        db.updateLemma(createdId, lemma)
      }
    }

    /** @inheritdoc */
    final override def createLemma(): LemmaID = db.createLemma().toString

    /** @inheritdoc */
    final override def remove(name: String): Unit = db.deleteLemma(name.toInt)

    /** @inheritdoc */
    final override def removeAll(folder: String): Unit = ???

    /** @inheritdoc */
    final override def deleteDatabase(): Unit = db.deleteAllLemmas()

    /** @inheritdoc */
    override def version(): VersionNumber = versionOf(db)
  }

  /** Creates a new cached lemma DB backed by `db`. */
  def cachedSQLiteLemmaDB(db: SQLiteDB): LemmaDB = new CachedLemmaDB(new UncachedSQLiteLemmaDB(db))

  /** Accesses the SQLite DB at location `dblocation`. */
  class SQLiteDB(val dblocation: String) extends DBAbstraction {
    val sqldb: jdbc.SQLiteProfile.backend.JdbcDatabaseDef = {
      val config = new SQLiteConfig()
      /* Enable write-ahead logging for SQLite - significantly improves write performance */
      config.setJournalMode(JournalMode.WAL)
      /* Enable foreign key support (off by default) */
      config.enforceForeignKeys(true)
      /* Note: Setting synchronous = NORMAL introduces some risk of database corruption during power loss. According
       * to official documentation, that risk is less than the risk of the hard drive failing completely, but we
       * should at least be aware that the risk exists. Initial testing showed this to be about 8 times faster, so
       * it seems worth the risk. */
      config.setSynchronous(SynchronousMode.NORMAL)

      val ds = new SQLiteDataSource()
      ds.setUrl("jdbc:sqlite:" + dblocation)
      ds.setConfig(config)

      // The upgrade guide mentions the DatabaseDef must always be shut down
      // https://scala-slick.org/doc/3.0.0/upgrade.html#closing-databases
      // But Getting Started says it's fine when the JVM process terminates anyway
      // https://scala-slick.org/doc/3.2.3/gettingstarted.html#database-configuration
      // Meaning it is probably fine not to shut it down manually here (though it would be good form)
      SQLiteProfile.api.Database.forDataSource(ds, maxConnections = Some(1))
    }
    private val lemmaDB = cachedSQLiteLemmaDB(this)

    /** The database session */
    private var currentSession: Session = _

    // <editor-fold desc="Database interaction">

    /** Run an asynchronous database action synchronously (not synchronized). */
    private def run[T](action: DBIO[T]): T = {
      val future = sqldb.run(action)
      Await.result(future, atMost = Duration.Inf)
    }

    /** Run an asynchronous database action synchronously (not synchronized) and in a transaction. */
    private def runTransactionally[T](action: DBIO[T]): T = { run(action.transactionally) }

    /** Initializes the database location. */
    private def ensureExists(location: String): Unit = if (!new java.io.File(location).exists()) { cleanup(location) }
    ensureExists(DBAbstractionObj.dblocation)
    ensureExists(DBAbstractionObj.testLocation)

    /** Syncs the database to the file system. */
    final override def syncDatabase(): Unit = { run(sqlu"PRAGMA wal_checkpoint(FULL)") }

    /** @inheritdoc */
    final override def cleanup(): Unit = cleanup(DBAbstractionObj.dblocation)

    /** Initializes a new database. */
    def cleanup(which: String): Unit = {
      val dbFile = this.getClass.getResourceAsStream("/keymaerax.sqlite")
      val target = new java.io.File(which)
      val targetStream = new FileOutputStream(target)
      targetStream.getChannel.transferFrom(Channels.newChannel(dbFile), 0, Long.MaxValue)
      targetStream.close()
      dbFile.close()
    }

    /** Converts the Int-encoded boolean `x` to bool. */
    private[this] def sqliteBoolToBoolean(x: Int) =
      if (x == 0) false
      else if (x == 1) true
      else throw new IllegalStateException("Expected boolean encoded as either 0 or 1, but got " + x)

    private[this] def splitNameLabel(s: String): (String, Option[String]) =
      s.split(Regex.quote(RULENAME_BRANCH_SEPARATOR)).toList match {
        case rn :: Nil => (rn, None)
        case rn :: bl :: Nil => (rn, Some(bl))
      }

    // </editor-fold>

    // <editor-fold desc="Lemma storage">

    /** Creates a lemma entry in the database and returns its ID. */
    private[SQLite] def createLemma(): Int =
      synchronized { runTransactionally((Lemmas.map(_.lemma) returning Lemmas.map(_._Id.get)) += None) }

    /** Updates the database to have `lemmaId` reflect `lemma`. */
    private[SQLite] def updateLemma(lemmaId: Int, lemma: String): Unit =
      synchronized { runTransactionally(Lemmas.filter(_._Id === lemmaId).map(_.lemma).update(Some(lemma))) }

    private[this] lazy val containsLemmaQuery = Compiled((lemmaId: Rep[Int]) => Lemmas.filter(_._Id === lemmaId).exists)

    /** Returns true if the database contains the lemma identified by `lemmaId`, false otherwise. */
    private[SQLite] def containsLemma(lemmaId: Int): Boolean =
      synchronized { runTransactionally(containsLemmaQuery(lemmaId).result) }

    private[this] lazy val lemmaQuery = Compiled((lemmaId: Rep[Int]) =>
      Lemmas.filter(l => l._Id === lemmaId && l.lemma.isDefined).map(l => (l._Id.get, l.lemma.get))
    )

    /** Retrieves lemmas identified by `lemmaIds` in bulk. */
    private[SQLite] def getLemmas(lemmaIds: List[Int]): Option[List[(Int, String)]] = synchronized {
      if (lemmaIds.size > 1) {
        // @todo Code Review: This code should be revised to either select in SQL land from lemmaIds, or read all and filter, or read individual ones in a single transaction
        // @todo Code Review: for lemmas that are in lemmaIds, assert not None, for all other lemmas, filter them out instead of converting to empty string
        // @fix: revised to use inSetBind (results in a query SELECT from Lemmas WHERE _Id IN (...), keep l.lemma option, filter below
        val lemmaQuery = for {
          l <- Lemmas if l._Id.inSetBind(lemmaIds)
          if l.lemma.isDefined
        } yield (l._Id.get, l.lemma.get)
        try {
          // @todo Code Review: check that lemmaIds really should not have "" names now
          // @fix: implement LemmaDB contract right here
          val lemmas = runTransactionally(lemmaQuery.result).toList
          if (lemmas.size != lemmaIds.size) None else Some(lemmas)
        } catch { case _: Exception => None }
      } else if (lemmaIds.size == 1) {
        val lemmas = runTransactionally(lemmaQuery(lemmaIds.head).result).toList
        Some(lemmas)
      } else Some(Nil)
    }

    /** Deletes the lemma identified by `lemmaId` from the database. */
    private[SQLite] def deleteLemma(lemmaId: Int): Unit = synchronized {
      // check that it deleted exactly one row
      val deletedEntries = runTransactionally(Lemmas.filter(_._Id === lemmaId).delete)
      assert(deletedEntries == 1, "deleting one identifier should delete one entry")
    }

    /** Clears all lemmas from the database. */
    private[SQLite] def deleteAllLemmas(): Unit = synchronized { runTransactionally(Lemmas.delete) }

    // </editor-fold>

    // <editor-fold desc="Configuration storage">

    /** @inheritdoc */
    final override def getAllConfigurations: Set[ConfigurationPOJO] = synchronized {
      val config = runTransactionally(Config.result)
      config.filter(_.configname.isDefined).map(_.configname.get).map(getConfiguration).toSet
    }

    /**
     * Poorly named -- either update the config, or else insert an existing key. But in Mongo it was just update,
     * because of the nested documents thing.
     *
     * @param config
     *   The new configuration.
     */
    final override def updateConfiguration(config: ConfigurationPOJO): Unit = synchronized {
      config
        .config
        .foreach(kvp => {
          val key = kvp._1
          val value = kvp._2
          val configExists = Config.filter(c => c.configname === config.name && c.key === key).exists.result

          val action = configExists.flatMap(configExists =>
            if (configExists) {
              val query = for { l <- Config if l.configname === config.name && l.key === key } yield l.value
              query.update(Some(value))
            } else { Config.map(c => (c.configname.get, c.key.get, c.value.get)) += (config.name, key, value) }
          )

          runTransactionally(action)
        })
    }

    /** @inheritdoc */
    final override def getConfiguration(configName: String): ConfigurationPOJO = synchronized {
      val query = Config.filter(_.configname === configName).filter(_.key.isDefined)
      val kvp = runTransactionally(query.result).map(conf => (conf.key.get, conf.value.getOrElse(""))).toMap
      new ConfigurationPOJO(configName, kvp)
    }

    private def configWithDefault(config: String, subconfig: String, default: Int): Int =
      try { getConfiguration(config).config(subconfig).toInt }
      catch { case _: NoSuchElementException => default }

    // </editor-fold>

    // <editor-fold desc="Model storage">

    /** @inheritdoc */
    final override def getModelList(userId: String): List[ModelPOJO] = synchronized {
      val models = runTransactionally(Models.filter(_.userid === userId).result).toList
      models.map(element =>
        ModelPOJO(
          element._Id.get,
          element.userid.get,
          element.name.get,
          element.date.getOrElse(""),
          element.filecontents.getOrElse(""),
          element.description.getOrElse(""),
          element.publink.getOrElse(""),
          element.title.getOrElse(""),
          element.tactic,
          getNumAllProofSteps(element._Id.get),
          element.istemporary.getOrElse(0) == 1,
        )
      )
    }

    /** @inheritdoc */
    final override def getUniqueModelName(userId: String, modelName: String): String = {
      val query = Models.filter(_.userid === userId).filter(_.name.startsWith(modelName)).map(_.name)
      val models = run(query.result).toList
      if (models.isEmpty) modelName
      else {
        val max =
          (0 ::
            models
              .filter(_.isDefined)
              .map(s => Try(s.get.substring(modelName.length).trim().stripPrefix("(").stripSuffix(")").toInt).toOption)
              .filter(_.isDefined)
              .map(_.get)).max
        s"$modelName (${max + 1})"
      }
    }

    /** @inheritdoc */
    final override def createModel(
        userId: String,
        name: String,
        fileContents: String,
        date: String,
        description: Option[String] = None,
        publink: Option[String] = None,
        title: Option[String] = None,
        tactic: Option[String] = None,
    ): Option[Int] = synchronized {
      val action = Models
        .filter(_.userid === userId)
        .filter(_.name === name)
        .exists
        .result
        .flatMap(exists =>
          if (exists) { DBIO.successful(None) }
          else {
            val action =
              (Models.map(m =>
                (m.userid.get, m.name.get, m.filecontents.get, m.date.get, m.description, m.publink, m.title, m.tactic)
              ) returning Models.map(_._Id.get)) +=
                (userId, name, fileContents, date, description, publink, title, tactic)
            action.map(id => Some(id))
          }
        )
      runTransactionally(action)
    }

    /** @inheritdoc */
    final override def updateModel(
        modelId: Int,
        name: String,
        title: Option[String],
        description: Option[String],
        content: Option[String],
        tactic: Option[String],
    ): Unit = synchronized {
      val identicalModelExists = Models.filter(m => m._Id === modelId && m.filecontents === content).exists
      val proofStepsLen = Proofs
        .join(Executionsteps)
        .on((proofs, steps) => steps.proofid === proofs._Id)
        .filter({ case (proofs, _) => proofs.modelid === modelId })
        .length

      val action = identicalModelExists
        .zip(proofStepsLen)
        .result
        .flatMap({ case (identicalModelExists, proofStepsLen) =>
          assert(
            identicalModelExists || proofStepsLen <= 0,
            "Updating model content only possible for models without proof steps",
          )
          Models
            .filter(_._Id === modelId)
            .map(m => (m.name, m.title, m.description, m.filecontents, m.tactic))
            .update(Some(name), title, description, content, tactic)
        })

      runTransactionally(action)
    }

    /** @inheritdoc */
    final override def addModelTactic(modelId: String, fileContents: String): Option[Int] = synchronized {
      val mId = Integer.parseInt(modelId)
      val action = Models
        .filter(_._Id === mId)
        .filter(_.tactic.isEmpty)
        .exists
        .result
        .flatMap(exists =>
          if (exists) { DBIO.successful(None) }
          else { Models.filter(_._Id === mId).map(_.tactic).update(Some(fileContents)).map(id => Some(id)) }
        )

      runTransactionally(action)
    }

    /** @inheritdoc */
    final override def getModel(modelId: Int): ModelPOJO = synchronized {
      val models = runTransactionally(Models.filter(_._Id === modelId).result)
        .toList
        .map(m =>
          new ModelPOJO(
            m._Id.get,
            m.userid.get,
            m.name.getOrElse(""),
            m.date.getOrElse(""),
            m.filecontents.get,
            m.description.getOrElse(""),
            m.publink.getOrElse(""),
            m.title.getOrElse(""),
            m.tactic,
            getNumAllProofSteps(m._Id.get),
            m.istemporary.getOrElse(0) == 1,
          )
        )
      if (models.length < 1) throw new Exception("getModel type should be an Option")
      else if (models.length == 1) models.head
      else throw new Exception("Primary keys aren't unique in models table.")
    }

    /** @inheritdoc */
    final override def deleteModel(modelId: Int): Boolean = synchronized {
      val deleteModel = Models.filter(_._Id === modelId).delete
      val deleteProofs = Proofs.filter(_.modelid === modelId).delete
      runTransactionally(deleteModel.andThen(deleteProofs))
      true
    }

    /** @inheritdoc */
    final override def getInvariants(modelId: Int): Map[Expression, Formula] = {
      val model = getModel(modelId)
      var invariants: Map[Expression, Formula] = Map.empty
      Parser.parser.setAnnotationListener { case (program, formula) => invariants = invariants.+((program, formula)) }
      ArchiveParser.parseAsFormula(model.keyFile)
      invariants
    }

    // </editor-fold>

    // <editor-fold desc="User storage">

    /** @inheritdoc */
    final override def createUser(username: String, password: String, mode: String): Unit = {
      /* Store passwords as a salted hash. Allow configuring number of iterations
       * since we may conceivably want to change it after deployment for performance reasons */
      val iterations = configWithDefault("security", "passwordHashIterations", 10000)
      val saltLength = configWithDefault("security", "passwordSaltLength", 512)
      val (hash, salt) = Password.generateKey(password, iterations, saltLength)
      synchronized {
        runTransactionally(
          Users.map(u => (u.email.get, u.hash.get, u.salt.get, u.iterations.get, u.level.get)) +=
            (username, hash, salt, iterations, Integer.parseInt(mode))
        )
      }
    }

    /** @inheritdoc */
    final override def userExists(username: String): Boolean =
      synchronized { runTransactionally(Users.filter(_.email === username).exists.result) }

    /** @inheritdoc */
    final override def getUser(username: String): Option[UserPOJO] = synchronized {
      val users = runTransactionally(Users.filter(_.email === username).result)
        .map(m => new UserPOJO(m.email.get, m.level.get))
      if (users.length <= 1) users.headOption else throw new Exception("Primary keys aren't unique in models table.")
    }

    /** @inheritdoc */
    final override def checkPassword(username: String, password: String): Boolean = synchronized {
      runTransactionally(Users.filter(_.email === username).result).exists({ row =>
        val hash = Password.hash(password.toCharArray, row.salt.get.getBytes("UTF-8"), row.iterations.get)
        Password.hashEquals(hash, row.hash.get)
      })
    }

    /** @inheritdoc */
    final override def getTempUsers: List[UserPOJO] = synchronized {
      runTransactionally(Users.filter(_.level === 3).result).toList.map(m => new UserPOJO(m.email.get, m.level.get))
    }

    // </editor-fold>

    // <editor-fold desc="Proof storage">

    // This function does not run in the same transaction as whatever happens around it
    // but it should be fine since it does not modify the database in any way
    // so the worst that should happen is that the query results are slightly outdated
    private[this] def getNumAllProofSteps(modelId: Int): Int = {
      val query = Proofs
        .join(Executionsteps)
        .on((proofs, steps) => steps.proofid === proofs._Id)
        .filter({ case (proofs, _) => proofs.modelid === modelId })
        .length
      runTransactionally(query.result)
    }

    private[this] lazy val proofClosedQuery =
      Compiled((proofId: Rep[Int]) => Proofs.filter(p => p._Id === proofId && p.closed.getOrElse(0) === 1).exists)

    /** @inheritdoc */
    final override def isProofClosed(proofId: Int): Boolean =
      synchronized { runTransactionally(proofClosedQuery(proofId).result) }

    private[this] lazy val stepCountQuery = Compiled((proofId: Rep[Int]) =>
      Executionsteps
        .filter(row =>
          row.proofid === proofId && row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
        )
        .map(_._Id)
        .distinct
        .length
    )

    final override def proofExists(proofId: Int): Boolean =
      synchronized { runTransactionally(Proofs.filter(_._Id === proofId).exists.result) }

    /** @inheritdoc */
    final override def getProofInfo(proofId: Int): ProofPOJO = synchronized {
      // With all the calls to different parts of the database, I don't see a good way
      // to implement all of this in a single transaction. It's made even worse since
      // this function not only gets data from the database but also may update data.
      val q = for { p <- Proofs if p._Id === proofId } yield (p.modelid, p.lemmaid)
      run(q.result).headOption match {
        case Some((modelId, lemmaId)) =>
          if (lemmaId.isEmpty) {
            val (lemmaId, _) = initializeProofForModel(modelId.get, None)
            run(q.update(modelId, Some(lemmaId)))
          }

          val stepCount = run(stepCountQuery(proofId).result)
          val list = run(Proofs.filter(_._Id === proofId).result)
            .toList
            .map(p =>
              ProofPOJO(
                p._Id.get,
                p.modelid,
                p.name.getOrElse(""),
                p.description.getOrElse(""),
                p.date.getOrElse(""),
                stepCount,
                p.closed.getOrElse(0) == 1,
                p.lemmaid,
                p.istemporary.getOrElse(0) == 1,
                p.tactic,
              )
            )
          if (list.length > 1) throw new IllegalStateException("Duplicate proof " + proofId)
          else if (list.isEmpty) throw new IllegalStateException("Proof not found: " + proofId)
          else list.head
        case None => throw new IllegalStateException("Proof not found: " + proofId)
      }
    }

    /** @inheritdoc */
    final override def getProofsForUser(userId: String): List[(ProofPOJO, String)] = synchronized {
      val models = getModelList(userId)

      models.flatMap(model => {
        val modelName = model.name
        val proofs = getProofsForModel(model.modelId)
        proofs.map((_, modelName))
      })
    }

    private lazy val userOwnsProofQuery = Compiled((userId: Rep[String], proofId: Rep[Int]) => {
      (for {
        p <- Proofs.filter(_._Id === proofId)
        m <- Models.filter(_.userid === userId) if m._Id === p.modelid
      } yield p._Id).exists
    })

    /** @inheritdoc */
    final override def userOwnsProof(userId: String, proofId: String): Boolean =
      synchronized { runTransactionally(userOwnsProofQuery(userId, proofId.toInt).result) }

    /** @inheritdoc */
    final override def updateProofInfo(proof: ProofPOJO): Unit =
      synchronized { runTransactionally(Proofs.filter(_._Id === proof.proofId).update(proofPojoToRow(proof))) }

    /** Converts the proof meta information into database format. */
    private[this] def proofPojoToRow(p: ProofPOJO): ProofsRow = ProofsRow(
      _Id = Some(p.proofId),
      modelid = p.modelId,
      name = Some(p.name),
      description = Some(p.description),
      date = Some(p.date),
      closed = Some(if (p.closed) 1 else 0),
      lemmaid = p.provableId,
      istemporary = Some(if (p.temporary) 1 else 0),
      tactic = p.tactic,
    )

    /** @inheritdoc */
    final override def getProofsForModel(modelId: Int): List[ProofPOJO] = synchronized {
      run(Proofs.filter(_.modelid === modelId).result)
        .toList
        .map(p => {
          val stepCount = run(stepCountQuery(p._Id.get).result) // @todo avoid ripple loading
          val closed: Boolean = sqliteBoolToBoolean(p.closed.getOrElse(0))
          val temporary: Boolean = sqliteBoolToBoolean(p.istemporary.getOrElse(0))
          ProofPOJO(
            p._Id.get,
            p.modelid,
            p.name.getOrElse(""),
            p.description.getOrElse(""),
            p.date.getOrElse(""),
            stepCount,
            closed,
            p.lemmaid,
            temporary,
            p.tactic,
          )
        })
    }

    /** @inheritdoc */
    final override def deleteProofSteps(proofId: Int): Int = synchronized {
      val countBefore = run(stepCountQuery(proofId).result)
      // @note count returned from .delete does not reflect the number of deleted steps correctly
      run(Executionsteps.filter(_.proofid === proofId).delete)
      val countAfter = run(stepCountQuery(proofId).result)
      // @note deleting all steps, no need to update subgoal count
      val q = for { proof <- Proofs if proof._Id === proofId } yield (proof.closed, proof.lemmaid)
      val (_, lemmaid) = run(q.result).head
      // delete associated lemma
      run(Lemmas.filter(_._Id === lemmaid).delete)
      // reset closed flag and initial lemma
      run(q.update(Some(0), None))
      countBefore - countAfter
    }

    /** @inheritdoc */
    final override def deleteProof(proofId: Int): Boolean = synchronized {
      deleteProofSteps(proofId)
      run(Proofs.filter(x => x._Id === proofId).delete) == 1
    }

    /**
     * Initializes the proof by creating a provable from the model, returns the provable ID and optional substituted
     * tactic.
     */
    private[this] def initializeProofForModel(modelId: Int, tactic: Option[String]): (Int, Option[String]) = {
      val model = getModel(modelId)
      val entry = ArchiveParser.parseProblem(model.keyFile, parseTactics = false)
      val d = entry.defs
      val problem = entry.model.asInstanceOf[Formula]

      val substTactic = tactic match {
        case None => None
        case Some(t) => Some(BellePrettyPrinter(ArchiveParser.tacticParser(t)))
      }

      val provable = ProvableSig.startProof(problem, d)
      (createProvable(provable), substTactic)
    }

    /** @inheritdoc */
    final override def createProofForModel(
        modelId: Int,
        name: String,
        description: String,
        date: String,
        tactic: Option[String],
    ): Int = synchronized {
      val (provableId, substTactic) = initializeProofForModel(modelId, tactic)
      val action =
        (Proofs.map(p =>
          (
            p.modelid.get,
            p.name.get,
            p.description.get,
            p.date.get,
            p.closed.get,
            p.lemmaid.get,
            p.istemporary.get,
            p.tactic,
          )
        ) returning Proofs.map(_._Id.get)) += (modelId, name, description, date, 0, provableId, 0, substTactic)

      run(action)
    }

    /** @inheritdoc */
    final override def createProof(provable: ProvableSig): Int = synchronized {
      val provableId = createProvable(provable)
      val action =
        (Proofs.map(p => (p.closed.get, p.lemmaid.get, p.istemporary.get)) returning Proofs.map(_._Id.get)) +=
          (0, provableId, 1)

      //      val executableId = addBelleExpr(TactixLibrary.nil)
      //      addExecutionStep(ExecutionStepPOJO(None, proofId, None, None, Some(0), None, 0,
      //        ExecutionStepStatus.Finished, executableId, None, None, Some(provableId), userExecuted=false, "start"))

      run(action)
    }

    /** @inheritdoc */
    final override def deleteProvable(provableId: Int): Boolean = ???

    /** @inheritdoc */
    final override def addExecutionStep(step: ExecutionStepPOJO): Int = synchronized {
      val status = ExecutionStepStatus.toString(step.status)
      val steps = Executionsteps.map(dbstep =>
        (
          dbstep.proofid.get,
          dbstep.previousstep,
          dbstep.branchorder,
          dbstep.status.get,
          dbstep.executableid.get,
          dbstep.inputprovableid,
          dbstep.resultprovableid,
          dbstep.localprovableid,
          dbstep.userexecuted.get,
          dbstep.childrenrecorded.get,
          dbstep.rulename.get,
        )
      ) returning Executionsteps.map(_._Id.get)
      val stepId = run(
        steps +=
          (
            step.executionId,
            step.previousStep,
            step.branchOrder,
            status,
            step.executableId,
            step.inputProvableId,
            step.resultProvableId,
            step.localProvableId,
            step.userExecuted.toString,
            false.toString,
            step.ruleName,
          )
      )

      updateOpenSubgoalsCount(step.executionId, step.previousStep)

      stepId
    }

    /** @inheritdoc */
    final override def addAlternative(alternativeTo: Int, inputProvable: ProvableSig, trace: ExecutionTrace): Unit = {
      //      def get(stepId: Int) = {
      //        Executionsteps.filter(_._Id === stepId).list match {
      //          case Nil => throw new Exception("Execution step not found")
      //          case step :: _ => step
      //        }
      //      }
      //      val oldStep = get(alternativeTo)
      //      def addSteps(prev: Option[Int], globalProvable:ProvableSig, steps:List[ExecutionStep]): Unit = {
      //        if (steps.nonEmpty) {
      //          val thisStep = steps.head
      //          val thisPOJO = get(thisStep.stepId)
      //          val localProvable = getProvable(thisPOJO.localprovableid.get).provable
      //          val outputProvable = globalProvable(localProvable, thisStep.branch)
      //          val newStep = ExecutionStepPOJO(None, oldStep.executionid.get, prev, None, Some(thisStep.branch),
      //            None, oldStep.alternativeorder.get + 1, ExecutionStepStatus.fromString(thisPOJO.status.get), thisPOJO.executableid.get,
      //            None, None, thisPOJO.localprovableid, thisPOJO.userexecuted.get.toBoolean, thisPOJO.rulename.get, localProvable.subgoals.size)
      //          val newId = addExecutionStep(newStep)
      //          addSteps(Some(newId), outputProvable, steps.tail)
      //        }
      //      }
      //      if(trace.steps.isEmpty) {
      //        // Insert a null tactic with a higher alternative order
      //        val nilExecutable = addBelleExpr(TactixLibrary.nil)
      //        val localConclusion = inputProvable.subgoals(0)
      //        // Generate a no-op local provable whose conclusion matches with the current state of the proof.
      //        val localProvable = ProvableSig.startProof(localConclusion)
      //        val newLocalProvableID = createProvable(localProvable)
      //        val step = ExecutionStepPOJO(None, oldStep.executionid.get, oldStep.previousstep, None, Some(0), None,
      //          oldStep.alternativeorder.get + 1, ExecutionStepStatus.Finished, nilExecutable, oldStep.inputprovableid,
      //          oldStep.inputprovableid, Some(newLocalProvableID), userExecuted=false, "nil", localProvable.subgoals.size)
      //        addExecutionStep(step)
      //      } else {
      //        addSteps(oldStep.previousstep, inputProvable, trace.steps)
      //      }
    }

    /** @inheritdoc */
    final override def addBelleExpr(expr: BelleExpr): Int = synchronized {
      val executableId =
        (Executables.map(_.belleexpr) returning Executables.map(_._Id.get)) += Some(BellePrettyPrinter(expr))
      runTransactionally(executableId)
    }

    /** @inheritdoc */
    final override def createProvable(p: ProvableSig): Int = synchronized {
      val lemma =
        Lemma(p, Lemma.requiredEvidence(p, List(ToolEvidence(List("input" -> p.prettyString, "output" -> "true")))))
      lemmaDB.add(lemma).toInt
    }

    /** @inheritdoc */
    final override def getExecutable(executableId: Int): ExecutablePOJO = getExecutables(List(executableId)).head

    /** Allow retrieving executables in bulk to reduce the number of database queries. */
    private[this] def getExecutables(executableIds: List[Int]): List[ExecutablePOJO] = synchronized {
      val q = for { exe <- Executables if exe._Id inSetBind executableIds } yield (exe._Id.get, exe.belleexpr.get)
      val executableMap = run(q.result).map(exe => (exe._1, ExecutablePOJO(exe._1, exe._2))).toMap
      try { executableIds.map(executableMap) }
      catch { case _: Exception => throw new ProverException("getExecutable type should be an Option") }
    }

    /** @inheritdoc */
    final override def getProvable(lemmaId: Int): ProvablePOJO = loadProvables(List(lemmaId)).head

    private[this] def loadProvables(lemmaIds: List[Int]): List[ProvablePOJO] = {
      lemmaDB.get(lemmaIds.map(_.toString)) match {
        case None => throw new Exception(" No lemma for one of these IDs: " + lemmaIds)
        case Some(lemmas) => lemmas.zipWithIndex.map({ case (lemma, id) => ProvablePOJO(id, lemma.fact) })
      }
    }

    /** @inheritdoc */
    final override def updateExecutionStep(executionStepId: Int, step: ExecutionStepPOJO): Unit = synchronized {
      // update step
      val action = Executionsteps
        .filter(_._Id === executionStepId)
        .map(dbstep =>
          (
            dbstep.proofid.get,
            dbstep.previousstep,
            dbstep.branchorder,
            dbstep.status.get,
            dbstep.executableid.get,
            dbstep.inputprovableid,
            dbstep.resultprovableid,
            dbstep.localprovableid,
            dbstep.userexecuted.get,
            dbstep.childrenrecorded.get,
            dbstep.rulename.get,
            dbstep.numsubgoals,
            dbstep.numopensubgoals,
          )
        )
        .update((
          step.executionId,
          step.previousStep,
          step.branchOrder,
          ExecutionStepStatus.toString(step.status),
          step.executableId,
          step.inputProvableId,
          step.resultProvableId,
          step.localProvableId,
          step.userExecuted.toString,
          false.toString,
          // @todo store branch labels separately
          step.ruleName + RULENAME_BRANCH_SEPARATOR + step.branchLabel.getOrElse(""),
          step.numSubgoals,
          step.numOpenSubgoals,
        ))
      run(action)

      // update parent's open subgoals
      updateOpenSubgoalsCount(step.executionId, step.previousStep)
    }

    private lazy val stepQuery = Compiled((proofId: Rep[Int], stepId: Rep[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).map(_.numsubgoals)
    )

    private lazy val succStepCountQuery = Compiled((proofId: Rep[Int], stepId: Rep[Int]) =>
      Executionsteps
        .filter(row =>
          row.proofid === proofId && row.previousstep === stepId &&
            row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
        )
        .map(_._Id)
        .distinct
        .length
    )

    /** Recompute the open subgoals count of a step. */
    private[this] def updateOpenSubgoalsCount(proofId: Int, stepId: Option[Int]): Unit = {
      stepId match {
        case None => // nothing to do
        case Some(sId) =>
          val succStepsCount = succStepCountQuery(proofId, sId)
          val totalSubgoals = stepQuery(proofId, sId)
          val action = succStepsCount
            .result
            .zip(totalSubgoals.result)
            .flatMap({ case (succStepsCount, totalSubgoals) =>
              // @note select+update is faster than increment/decrement numSubGoals column
              Executionsteps.filter(_._Id === sId).map(_.numopensubgoals).update(totalSubgoals.head - succStepsCount)
            })
          runTransactionally(action)
      }
    }

    private lazy val stepParentQuery = Compiled((proofId: Rep[Int], stepId: Rep[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).map(_.previousstep)
    )

    /** @inheritdoc */
    final override def deleteExecutionStep(proofId: Int, stepId: Int): Unit = {
      // val succStepsQuery = Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId)
      val parent = run(stepParentQuery(proofId, stepId).result).head
      run(Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).delete)
      updateOpenSubgoalsCount(proofId, parent)
    }

    private lazy val executionStepsQuery = Compiled((proofId: Rep[Int]) =>
      Executionsteps
        .filter(row =>
          row.proofid === proofId && row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
        )
        .sortBy(e => (e.previousstep.asc, e.branchorder.desc))
    )

    private[this] def proofSteps(executionId: Int): List[ExecutionStepPOJO] = synchronized {
      /* The Executionsteps table may contain many alternate histories for the same execution. In order to reconstruct
       * the current state of the world, we must pick the most recent alternative at every opportunity.*/
      var steps = runTransactionally(executionStepsQuery(executionId).result)
      var prevIds: List[Option[Int]] = List(None)
      var revResult: List[ExecutionStepPOJO] = Nil
      while (prevIds.nonEmpty) {
        val prevId = prevIds.head
        val (headSteps, tailSteps) = steps.partition(_.previousstep == prevId)
        if (headSteps.nonEmpty) {
          val head = headSteps.head
          val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(head.rulename.get)
          revResult = ExecutionStepPOJO(
            head._Id,
            head.proofid.get,
            head.previousstep,
            head.branchorder,
            ExecutionStepStatus.fromString(head.status.get),
            head.executableid.get,
            head.inputprovableid,
            head.resultprovableid,
            head.localprovableid,
            head.userexecuted.get.toBoolean,
            ruleName,
            branchLabel,
            head.numsubgoals,
            head.numopensubgoals,
          ) :: revResult
          if (headSteps.tail.isEmpty) prevIds = prevIds.tail
          prevIds = head._Id :: prevIds
          steps = headSteps.tail ++ tailSteps
        } else {
          prevIds = prevIds.tail
          steps = tailSteps
        }
      }
      revResult.reverse
    }

    /** Zips execution steps with auxiliary information (executable tactics, provables). */
    private[this] def zipTrace(
        executionSteps: List[ExecutionStepPOJO],
        provables: Option[(ProvableSig, Map[Option[Int], ProvableSig])],
    ): List[ExecutionStep] = {
      executionSteps match {
        case step :: steps =>
          val localProvable: () => ProvableSig = provables match {
            case None => () => getProvable(step.localProvableId.get).provable
            case Some((rootProvable, localProvables)) =>
              val localProvable = localProvables(step.stepId)
              val inputProvable = step.previousStep match {
                case prevId @ Some(_) => localProvables(prevId)
                case None => rootProvable
              }
              assert(
                step.branchOrder < inputProvable.subgoals.size,
                "Open branch index " + step.branchOrder + " should point to a subgoal, but got only " +
                  inputProvable.subgoals.size + " subgoals:\n" +
                  inputProvable.subgoals.map(_.prettyString).mkString("\n"),
              )
              assert(
                inputProvable.subgoals(step.branchOrder) == localProvable.conclusion,
                "Conclusion of subderivation " + localProvable.conclusion + " should match open goal " +
                  inputProvable.subgoals(step.branchOrder) + " (subgoal " + step.branchOrder + ")",
              )
              () => localProvable
          }
          val successorIds = steps.filter(_.previousStep == step.stepId).map(_.stepId.get)
          ExecutionStep(
            step.stepId.get,
            step.previousStep,
            step.executionId,
            localProvable,
            step.branchOrder,
            step.numSubgoals,
            step.numOpenSubgoals,
            successorIds,
            step.ruleName,
            step.executableId,
            step.userExecuted,
          ) :: zipTrace(steps, provables)
        case Nil => Nil
        case _ => throw new ProverException("Bug in zipTrace")
      }
    }

    /** @inheritdoc */
    final override def getExecutionSteps(executionId: Int): List[ExecutionStepPOJO] = proofSteps(executionId)

    private lazy val firstExecutionStepQuery = Compiled((proofId: Rep[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId && row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished) &&
          row.previousstep.isEmpty
      )
    )

    /** @inheritdoc */
    final override def getFirstExecutionStep(proofId: Int): Option[ExecutionStepPOJO] = runTransactionally(
      firstExecutionStepQuery(proofId).result
    ).headOption
      .map(step => {
        val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
        ExecutionStepPOJO(
          step._Id,
          step.proofid.get,
          step.previousstep,
          step.branchorder,
          ExecutionStepStatus.fromString(step.status.get),
          step.executableid.get,
          step.inputprovableid,
          step.resultprovableid,
          step.localprovableid,
          step.userexecuted.get.toBoolean,
          ruleName,
          branchLabel,
          step.numsubgoals,
          step.numopensubgoals,
        )
      })

    // </editor-fold>

    // <editor-fold desc="Proof agenda">

    /** @inheritdoc */
    final override def addAgendaItem(proofId: Int, initialProofNode: ProofTreeNodeId, displayName: String): Int =
      synchronized {
        val (stepId, subgoalId) = tupleId(initialProofNode)
        runTransactionally(
          (Agendaitems.map(item => (item.proofid.get, item.stepid, item.subgoalid, item.displayname.get)) returning
            Agendaitems.map(_._Id.get)) += (proofId, stepId, subgoalId, displayName)
        )
      }

    /** @inheritdoc */
    final override def updateAgendaItem(item: AgendaItemPOJO): Unit = synchronized {
      val (stepId, subgoalId) = tupleId(item.initialProofNode)
      runTransactionally(
        Agendaitems
          .filter(_._Id === item.itemId)
          .map(dbitem => (dbitem.proofid.get, dbitem.stepid, dbitem.subgoalid, dbitem.displayname.get))
          .update((item.proofId, stepId, subgoalId, item.displayName))
      )
    }

    /** @inheritdoc */
    final override def agendaItemsForProof(proofId: Int): List[AgendaItemPOJO] = synchronized {
      runTransactionally(Agendaitems.filter(_.proofid === proofId).result)
        .toList
        .map(item =>
          AgendaItemPOJO(
            item._Id.get,
            item.proofid.get,
            DbStepPathNodeId(item.stepid, item.subgoalid),
            item.displayname.get,
          )
        )
    }

    /** @inheritdoc */
    final override def getAgendaItem(proofId: Int, initialProofNode: ProofTreeNodeId): Option[AgendaItemPOJO] = {
      val (stepId, subgoalId) = tupleId(initialProofNode)
      synchronized {
        runTransactionally(
          Agendaitems
            .filter { row => row.proofid === proofId && row.stepid === stepId && row.subgoalid === subgoalId }
            .result
        ).toList
          .map(item =>
            AgendaItemPOJO(
              item._Id.get,
              item.proofid.get,
              DbStepPathNodeId(item.stepid, item.subgoalid),
              item.displayname.get,
            )
          )
          .headOption
      }
    }

    // </editor-fold>

    // <editor-fold desc="Proof tree">

    /** Turns the proof node `id` into a tuple. */
    private def tupleId(id: ProofTreeNodeId): (Option[Int], Option[Int]) =
      id match { case DbStepPathNodeId(step, branch) => (step, branch) }

    private lazy val openStepsQuery = Compiled((proofId: Rep[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId && row.numopensubgoals > 0 &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
      )
    )

    private lazy val leavesQuery = Compiled((proofId: Rep[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId && (row.numsubgoals === 0 || row.numopensubgoals > 0) &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
      )
    )

    // performance degrades a little with increasing database volume
    private def closedBranchesSql(proofId: Int, openSteps: Set[Int]) =
      sql"""SELECT previousStep,group_concat(branchOrder) FROM executionSteps WHERE proofId=$proofId AND status='Finished' AND previousStep IN (#${openSteps
          .mkString(",")}) GROUP BY previousStep""".as[(Int, String)]

    private def getPlainFinishedSteps(
        proofId: Int,
        steps: List[Executionsteps#TableElementType],
    ): List[(ExecutionStepPOJO, List[Int])] = synchronized {
      val stepsPOJOs = steps.map(step => {
        val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
        ExecutionStepPOJO(
          step._Id,
          step.proofid.get,
          step.previousstep,
          step.branchorder,
          ExecutionStepStatus.fromString(step.status.get),
          step.executableid.get,
          step.inputprovableid,
          step.resultprovableid,
          step.localprovableid,
          step.userexecuted.get.toBoolean,
          ruleName,
          branchLabel,
          step.numsubgoals,
          step.numopensubgoals,
        )
      })
      val closedBranches = run(closedBranchesSql(proofId, stepsPOJOs.flatMap(_.stepId).toSet)).toMap

      def parseClosedBranches(closed: Option[String]): List[Int] = closed match {
        case None => Nil
        case Some(s) => s.split(",").map(_.toInt).toList
      }

      stepsPOJOs.map(s => (s, parseClosedBranches(closedBranches.get(s.stepId.get))))
    }

    /** @inheritdoc */
    final override def getPlainOpenSteps(proofId: Int): List[(ExecutionStepPOJO, List[Int])] =
      getPlainFinishedSteps(proofId, run(openStepsQuery(proofId).result).toList)

    /** @inheritdoc */
    final override def getPlainLeafSteps(proofId: Int): List[(ExecutionStepPOJO, List[Int])] =
      getPlainFinishedSteps(proofId, run(leavesQuery(proofId).result).toList)

    private lazy val executionStepQuery = Compiled((proofId: Rep[Int], stepId: Rep[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId && row._Id === stepId &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
      )
    )

    /** @inheritdoc */
    final override def getPlainExecutionStep(proofId: Int, stepId: Int): Option[ExecutionStepPOJO] = {
      run(executionStepQuery(proofId, stepId).result).headOption match {
        case None => None
        case Some(step) =>
          val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
          Some(ExecutionStepPOJO(
            step._Id,
            step.proofid.get,
            step.previousstep,
            step.branchorder,
            ExecutionStepStatus.fromString(step.status.get),
            step.executableid.get,
            step.inputprovableid,
            step.resultprovableid,
            step.localprovableid,
            step.userexecuted.get.toBoolean,
            ruleName,
            branchLabel,
            step.numsubgoals,
            step.numopensubgoals,
          ))
      }
    }

    private lazy val stepSuccessorsQuery = Compiled((proofId: Rep[Int], prevStepId: Rep[Int], branchOrder: Rep[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId && row.previousstep === prevStepId && row.branchorder === branchOrder &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)
      )
    )

    /** @inheritdoc */
    final override def getPlainStepSuccessors(
        proofId: Int,
        prevStepId: Int,
        branchOrder: Int,
    ): List[ExecutionStepPOJO] = {
      run(stepSuccessorsQuery(proofId, prevStepId, branchOrder).result)
        .map(step => {
          val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
          ExecutionStepPOJO(
            step._Id,
            step.proofid.get,
            step.previousstep,
            step.branchorder,
            ExecutionStepStatus.fromString(step.status.get),
            step.executableid.get,
            step.inputprovableid,
            step.resultprovableid,
            step.localprovableid,
            step.userexecuted.get.toBoolean,
            ruleName,
            branchLabel,
            step.numsubgoals,
            step.numopensubgoals,
          )
        })
        .toList
    }

    /** @inheritdoc */
    final override def getExecutionStep(proofId: Int, stepId: Int): Option[ExecutionStep] =
      getPlainExecutionStep(proofId, stepId) match {
        case None => None
        case Some(step) =>
          val localProvable = getProvable(step.localProvableId.get).provable
          // @todo extend getPlainExecutionStep to query for successor IDs right away
          val successorIds = getExecutionSteps(proofId).filter(_.previousStep == step.stepId).map(_.stepId.get)
          Some(ExecutionStep(
            step.stepId.get,
            step.previousStep,
            step.executionId,
            () => localProvable,
            step.branchOrder,
            step.numSubgoals,
            step.numOpenSubgoals,
            successorIds,
            step.ruleName,
            step.executableId,
            step.userExecuted,
          ))
      }

    /** @inheritdoc */
    final override def getStepProvable(proofId: Int, stepId: Option[Int], subgoal: Option[Int]): Option[ProvableSig] =
      (stepId, subgoal) match {
        case (None, None) => getProofInfo(proofId).provableId match {
            case None => None
            case Some(pId) => Some(getProvable(pId).provable)
          }
        case (Some(stId), None) => getPlainExecutionStep(proofId, stId) match {
            case Some(step) => step.localProvableId match {
                case None => None
                case Some(lpId) => Some(getProvable(lpId).provable)
              }
            case None => throw new IllegalArgumentException("Unknown step ID " + stId)
          }
        case (stId, Some(sgIdx)) => getStepProvable(proofId, stId, None) match {
            case None => None
            case Some(p) => Some(p.sub(sgIdx))
          }
      }

    /** @inheritdoc */
    final override def getExecutionTrace(proofId: Int, withProvables: Boolean = true): ExecutionTrace = {
      /* This method has proven itself to be a resource hog, so this implementation attempts to minimize the number of
         DB calls. */
      val stepsCount = run(stepCountQuery(proofId).result)
      if (stepsCount <= 0) { ExecutionTrace(proofId.toString, proofId.toString, Nil) }
      else {
        // @todo sqlite has a maximum of 999 variables in a query (could be changed, but any number might be too small)
        // -> may need to query steps and provables joined, but how to benefit from cached lemma DB then?
        val steps = proofSteps(proofId)
        val provables =
          if (withProvables) {
            val provableIds = steps.map(_.localProvableId.get)
            val provables = steps.map(_.stepId).zip(loadProvables(provableIds).map(_.provable)).toMap
            val conclusion = provables(steps.head.stepId).conclusion
            val initProvable = ProvableSig.startPlainProof(conclusion)
            Some((initProvable, provables))
          } else None
        val traceSteps = zipTrace(steps, provables)
        ExecutionTrace(proofId.toString, proofId.toString, traceSteps)
      }
    }

    // </editor-fold>

  }
}
