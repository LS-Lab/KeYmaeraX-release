/*
 * Copyright (c) Carnegie Mellon University, Karlsruhe Institute of Technology.
 * See LICENSE.txt for the conditions of this license.
 */

package edu.cmu.cs.ls.keymaerax.codegen

import edu.cmu.cs.ls.keymaerax.codegen.PythonPrettyPrinter.{nameIdentifier, printSort}
import edu.cmu.cs.ls.keymaerax.codegen.PythonGenerator.{
  printHeader,
  printInputDeclaration,
  printParameterDeclaration,
  printStateDeclaration,
  printVerdictDeclaration,
  IMPORT_STATEMENTS,
}
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.parser.{Declaration, Name, Signature}

/**
 * Python code generator header and declaration printing.
 * @author
 *   Stefan Mitsch
 */
object PythonGenerator {
  val RESERVED_NAMES = Set("self", "in", "val", "bool", "def", "int", "float")

  /** Prints a file header */
  def printHeader(modelName: String): String = s"""#
                                                  |# ${if (modelName.nonEmpty) modelName + ".py" else ""}
                                                  |# Generated by KeYmaera X
                                                  |#
                                                  |
                                                  |""".stripMargin

  /** Prints import statements. */
  val IMPORT_STATEMENTS: String = """from typing import Callable
                                    |import numpy as np
                                    |
                                    |""".stripMargin

  /** Prints a class declaration of class `name` with `fields` and documentation `comment`. */
  def printClassDeclaration[T <: NamedSymbol](name: String, fields: Set[T], comment: String): String = {
    val sortedVars = fields.toList.sorted[NamedSymbol]
    val names = sortedVars.map({
      case x: Variable => nameIdentifier(x) -> printSort(x.sort)
      case f: Function =>
        assert(!CodeGenerator.isInterpreted(f), "Parameter must not be an interpreted function")
        assert(f.domain == Unit, "If declared as function, parameter must have domain Unit, but has " + f.domain)
        nameIdentifier(f) -> printSort(f.sort)
    })
    val fieldDecls = names.map({ case (n, s) => n + ": " + s })
    val setFields = names.map(_._1).map(s => s"self.$s = $s")
    val printFields = names.map(_._1).map(s => s""""$s=" + str(self.$s)""").mkString(""" + ", " + """)
    val body = if (names.isEmpty) "self" else setFields.mkString("\n    ")
    s"""# $comment
       |class $name:
       |  def __init__(self${{ if (fieldDecls.nonEmpty) ", " else "" } + fieldDecls.mkString(", ")}):
       |    $body
       |  def __str__(self) -> str:
       |    return "$name(" + ${if (names.nonEmpty) printFields + " + " else ""} ")"
       |
       |""".stripMargin
  }

  /** Prints the parameters class declaration. */
  def printParameterDeclaration(parameters: Set[NamedSymbol]): String =
    printClassDeclaration("Params", parameters, "Model parameters")

  /** Prints the state variables class declaration. */
  def printStateDeclaration(stateVars: Set[BaseVariable]): String =
    printClassDeclaration("State", stateVars, "State (control choices, environment measurements etc.)")

  /** Prints the input (non-deterministically assigned variables) class declaration. */
  def printInputDeclaration(inputs: Set[BaseVariable]): String =
    printClassDeclaration("Input", inputs, "Values for resolving non-deterministic assignments in control code")

  /** Prints the verdict class declaration. */
  def printVerdictDeclaration(): String =
    printClassDeclaration("Verdict", Set(Variable("id"), Variable("val")), "Verdict identifier and value")
}

/**
 * Python code generator that prints a file header, include statements, declarations, and the output of `bodyGenerator`.
 * @author
 *   Stefan Mitsch
 */
class PythonGenerator(bodyGenerator: CodeGenerator, init: Formula, defs: Declaration) extends CodeGenerator {

  /**
   * Generate Python code for given expression using the data type cDataType throughout and the input list of variables
   */
  override def apply(
      expr: Expression,
      stateVars: Set[BaseVariable],
      inputVars: Set[BaseVariable],
      fileName: String,
  ): (String, String) = generateMonitoredCtrlCCode(expr, init, stateVars, inputVars, fileName)

  /** The name of the monitor/control function argument representing monitor parameters. */
  private val FUNC_PARAMS_NAME = "params"

  /** Compiles primitive expressions with the appropriate params/curr/pre struct location. */
  private def primitiveExprGenerator(parameters: Set[NamedSymbol]) = new PythonFormulaTermGenerator(
    {
      case t: Variable => if (parameters.contains(t)) FUNC_PARAMS_NAME + "." else ""
      case FuncOf(fn, Nothing) =>
        if (parameters.contains(fn)) FUNC_PARAMS_NAME + "."
        else throw new CodeGenerationException(
          "Non-posterior, non-parameter function symbol " + fn.prettyString + " is not supported"
        )
    },
    defs,
  )

  /** Prints the function definitions of `defs` that are used transitively in `expr`. */
  private def printFuncDefs(defs: Declaration, parameters: Set[NamedSymbol], expr: Expression): String = {
    // @note substs are topologically sorted, print in that order
    val projected = defs.project(List(expr))
    projected
      .substs
      .reverse
      .flatMap({
        case SubstitutionPair(FuncOf(what, _), _) => Some(what)
        case SubstitutionPair(PredOf(what, _), _) => Some(what)
        case _ => None
      })
      .map(name =>
        projected.decls.find({ case (Name(n, i), _) => name.name == n && name.index == i }) match {
          case Some((name, Signature(_, codomain, Some(args), Right(interpretation), _))) =>
            def ptype(s: Sort): String = s match {
              case Real => "np.float64"
              case Bool => "bool"
              case _ => throw new IllegalArgumentException("Sort " + s + " not supported")
            }
            val pargs = args.map({ case (n, s) => s"${n.prettyString}: ${ptype(s)}" }).mkString(", ")
            // @note ensure that args don't have both . and ._0
            assert(interpretation.forall(
              StaticSemantics
                .symbols(_)
                .flatMap({
                  case DotTerm(_, Some(i)) => Some(i)
                  case DotTerm(_, None) => Some(0)
                  case _ => None
                })
                .count(_ == 0) <= 1
            ))
            val argsSubst = USubst(
              args
                .zipWithIndex
                .flatMap({ case ((Name(n, idx), s), i) =>
                  (if (i == 0) List(SubstitutionPair(DotTerm(s, None), Variable(n, idx, s))) else Nil) :+
                    SubstitutionPair(DotTerm(s, Some(i)), Variable(n, idx, s))
                })
            )
            val body = interpretation match {
              case Some(FuncOf(Function(_, _, _, _, Some(interp)), arg)) =>
                s"""# todo: implement preserving the function characteristics
                   |#       ._0 = ${name.prettyString}(${arg.prettyString}) <-> ${interp.prettyString}
                   |#       where ._0 is the function result and ._1 is the function argument
                   |raise NotImplementedError""".stripMargin
              case Some(i) => "return " + primitiveExprGenerator(parameters)(argsSubst(i))._2
              case _ => """# todo: uninterpreted function symbol
                          |raise NotImplementedError""".stripMargin
            }
            def arguments(x: String): String = FUNC_PARAMS_NAME + ": Params" + (if (x.nonEmpty) ", " + x else "")
            s"""def ${name.prettyString}(${arguments(pargs)}) -> ${ptype(codomain)}:
               |  ${body.linesWithSeparators.map("  " + _).mkString.stripPrefix("  ")}
               |""".stripMargin
          case None => s"""# todo: undeclared symbol ${name.prettyString}
                          |raise NotImplementedError""".stripMargin
        }
      )
      .mkString("\n")
  }

  /**
   * Generates a monitor `expr` that switches between a controller and a fallback controller depending on the monitor
   * outcome.
   */
  private def generateMonitoredCtrlCCode(
      expr: Expression,
      init: Formula,
      stateVars: Set[BaseVariable],
      inputVars: Set[BaseVariable],
      fileName: String,
  ): (String, String) = {
    val names = StaticSemantics.symbols(expr).map(nameIdentifier)
    require(
      names.intersect(PythonGenerator.RESERVED_NAMES).isEmpty,
      "Unexpected reserved Python names encountered: " + names.intersect(PythonGenerator.RESERVED_NAMES).mkString(","),
    )
    val bodyParameters = CodeGenerator.getParameters(defs.exhaustiveSubst(expr), stateVars)
    val initParameters = CodeGenerator.getParameters(defs.exhaustiveSubst(init), stateVars)
    val parameters = bodyParameters ++ initParameters

    def initTermContainer(expr: Expression, params: Set[NamedSymbol]): String = expr match {
      case t: Variable if params.contains(t) => "params."
      case t: Variable if !params.contains(t) => "init."
      case FuncOf(fn, Nothing) if params.contains(fn) => "params."
      case _ => throw new CodeGenerationException(
          "Unsupported symbol " + expr.prettyString + " found in initial conditions " + init.prettyString
        )
    }

    val initGen = new SimpleMonitorGenerator(Symbol("resist"), defs, PythonPrettyPrinter, initTermContainer)
    val (_, initBody) = initGen(init, stateVars, inputVars, fileName)
    val (bodyBody, bodyDefs) = bodyGenerator(expr, stateVars, inputVars, fileName)

    val initCheck = s"""def checkInit(init: State, params: Params) -> Verdict:
                       |${initBody.linesWithSeparators.map("  " + _).mkString}
                       |""".stripMargin

    (
      printHeader(fileName) + IMPORT_STATEMENTS + printParameterDeclaration(parameters) +
        printStateDeclaration(stateVars) + printInputDeclaration(inputVars) + printVerdictDeclaration() +
        printFuncDefs(defs, parameters, expr) + initCheck + "\n" + bodyDefs,
      bodyBody,
    )
  }
}
