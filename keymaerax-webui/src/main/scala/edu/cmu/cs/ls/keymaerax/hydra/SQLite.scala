/**
  * Copyright (c) Carnegie Mellon University.
  * See LICENSE.txt for the conditions of this license.
  */
/**
  * @note Code Review 2016-08-02 LemmaDB aspects only
  */
package edu.cmu.cs.ls.keymaerax.hydra

import java.io.FileOutputStream
import java.nio.channels.Channels

import edu.cmu.cs.ls.keymaerax.bellerophon.parser.BellePrettyPrinter
import edu.cmu.cs.ls.keymaerax.bellerophon.BelleExpr
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.lemma._
import edu.cmu.cs.ls.keymaerax.parser.{ArchiveParser, Parser}
import edu.cmu.cs.ls.keymaerax.tools.ToolEvidence
import edu.cmu.cs.ls.keymaerax.core.Formula
import edu.cmu.cs.ls.keymaerax.pt.ProvableSig

import scala.collection.immutable.Nil
import scala.slick.driver.SQLiteDriver
import scala.util.Try

import scala.slick.jdbc.StaticQuery.interpolation
import scala.slick.driver.SQLiteDriver.simple._

/**
  * Database implementation based on SQLite and Slick. Stores and queries:
  * - Lemmas (used for storing proof steps)
  * - UI configuration
  * - Users
  * - Models
  * - Proofs and proof steps
  * - Proof agendas
  * - Proof trees
  *
  * Created by nfulton on 4/10/15.
  */
object SQLite {

  import Tables._

  /** Production database. */
  lazy val ProdDB: SQLiteDB = new SQLiteDB(DBAbstractionObj.dblocation)
  /** Use this for all unit tests that work with the database, so tests don't infect the production database */
  lazy val TestDB: SQLiteDB = new SQLiteDB(DBAbstractionObj.testLocation)

  private val RULENAME_BRANCH_SEPARATOR: String = "@@"

  /** Stores lemmas in the Lemma table of the given database. */
  class UncachedSQLiteLemmaDB(db: SQLiteDB) extends LemmaDBBase {
    /** @inheritdoc */
    final override def contains(lemmaID: LemmaID): Boolean = db.containsLemma(lemmaID.toInt)

    /** @inheritdoc */
    final override def readLemmas(ids: List[LemmaID]): Option[List[String]] = {
      val lemmaIds = ids.map(_.toInt)
      val lemmas = db.getLemmas(lemmaIds)
      assert(lemmas.isEmpty || lemmas.get.map(_._1) == lemmaIds, "Expected lemmas to be returned in requested order, but got\n" + lemmas.get.map(_._1).mkString(",") + " insteadn of\n" + lemmaIds.mkString(","))
      lemmas.map(_.map(_._2))
    }

    /** @inheritdoc */
    final override def writeLemma(id: LemmaID, lemma: String): Unit = {
      if (db.containsLemma(id.toInt)) db.updateLemma(id.toInt, lemma)
      else {
        val createdId = db.createLemma()
        assert(createdId.toInt == id.toInt, s"Cannot create a new lemma with a custom ID unless that ID happens to be the next one generated by the SQLite database (requested: $id; created: $createdId)")
        db.updateLemma(createdId, lemma)
      }
    }

    /** @inheritdoc */
    final override def createLemma(): LemmaID = db.createLemma().toString

    /** @inheritdoc */
    final override def remove(name: String): Unit = db.deleteLemma(name.toInt)

    /** @inheritdoc */
    final override def removeAll(folder: String): Unit = ???

    /** @inheritdoc */
    final override def deleteDatabase(): Unit = db.deleteAllLemmas()

    /** @inheritdoc */
    override def version(): String = db.getConfiguration("version").config("version")
  }

  /** Creates a new cached lemma DB backed by `db`.  */
  def cachedSQLiteLemmaDB(db: SQLiteDB): LemmaDB = new CachedLemmaDB(new UncachedSQLiteLemmaDB(db))

  /** Accesses the SQLite DB at location `dblocation`. */
  class SQLiteDB(val dblocation: String) extends DBAbstraction {
    val sqldb: SQLiteDriver.backend.DatabaseDef = Database.forURL("jdbc:sqlite:" + dblocation, driver = "org.sqlite.JDBC")
    private val lemmaDB = cachedSQLiteLemmaDB(this)
    /** The database session */
    private var currentSession: Session = _
    /* Statistics on the number of SQL operations performed in this session, useful for profiling. */
    private var nUpdates = 0
    private var nInserts = 0
    private var nSelects = 0

    //<editor-fold desc="Database interaction">

    /** The shared and reused database session. */
    implicit def session: Session = {
      if (currentSession == null || currentSession.conn.isClosed) {
        currentSession = sqldb.createSession()
        /* Enable write-ahead logging for SQLite - significantly improves write performance */
        sqlu"PRAGMA journal_mode = WAL".execute(currentSession)
        /* Enable foreign key support (off by default) */
        sqlu"PRAGMA foreign_keys = ON".execute(currentSession)
        /* Note: Setting synchronous = NORMAL introduces some risk of database corruption during power loss. According
         * to official documentation, that risk is less than the risk of the hard drive failing completely, but we
         * should at least be aware that the risk exists. Initial testing showed this to be about 8 times faster, so
         * it seems worth the risk. */
        sqlu"PRAGMA synchronous = NORMAL".execute(currentSession)
        sqlu"VACUUM".execute(currentSession)
      }
      currentSession
    }

    /** Initializes the database location. */
    private def ensureExists(location: String): Unit = if (!new java.io.File(location).exists()) { cleanup(location) }
    ensureExists(DBAbstractionObj.dblocation)
    ensureExists(DBAbstractionObj.testLocation)

    /** Wraps a session access, which is not thread-safe when connections are reused, inside a synchronized block. */
    def synchronizedTransaction[T](f: => T)(implicit session: Session): T = synchronized { session.withTransaction(f) }

    /** Syncs the database to the file system. */
    final override def syncDatabase(): Unit = {
      sqlu"PRAGMA wal_checkpoint(FULL)".execute(session)
    }

    /** @inheritdoc */
    final override def cleanup(): Unit = cleanup(DBAbstractionObj.dblocation)

    /** Initializes a new database. */
    def cleanup(which: String): Unit = {
      val dbFile = this.getClass.getResourceAsStream("/keymaerax.sqlite")
      val target = new java.io.File(which)
      val targetStream = new FileOutputStream(target)
      targetStream.getChannel.transferFrom(Channels.newChannel(dbFile), 0, Long.MaxValue)
      targetStream.close()
      dbFile.close()
    }

    /** Converts the Int-encoded boolean `x` to bool. */
    private[this] def sqliteBoolToBoolean(x: Int) = if (x == 0) false else if (x == 1) true else throw new IllegalStateException("Expected boolean encoded as either 0 or 1, but got " + x)

    private[this] def splitNameLabel(s: String): (String, Option[String]) = s.split(RULENAME_BRANCH_SEPARATOR).toList match {
      case rn :: Nil => (rn, None)
      case rn :: bl :: Nil => (rn, Some(bl))
    }

    def printStats(): Unit = {
      println("Updates: " + nUpdates + " Inserts: " + nInserts + " Selects: " + nSelects)
    }

    //</editor-fold>

    //<editor-fold desc="Lemma storage">

    /** Creates a lemma entry in the database and returns its ID.  */
    private[SQLite] def createLemma(): Int = synchronizedTransaction(
      (Lemmas.map(_.lemma) returning Lemmas.map(_._Id.get)).insert(None)
    )

    /** Updates the database to have `lemmaId` reflect `lemma`. */
    private[SQLite] def updateLemma(lemmaId: Int, lemma: String): Unit = synchronizedTransaction(
      Lemmas.filter(_._Id === lemmaId).map(_.lemma).update(Some(lemma))
    )

    private[this] lazy val containsLemmaQuery = Compiled((lemmaId: Column[Int]) =>
      Lemmas.filter(_._Id === lemmaId).exists)

    /** Returns true if the database contains the lemma identified by `lemmaId`, false otherwise. */
    private[SQLite] def containsLemma(lemmaId: Int): Boolean = synchronizedTransaction(containsLemmaQuery(lemmaId).run)

    private[this] lazy val lemmaQuery = Compiled((lemmaId: Column[Int]) =>
      Lemmas.filter(l => l._Id === lemmaId && l.lemma.isDefined).map(l =>
        (l._Id.getOrElse(throw new IllegalStateException("Lemma without ID stored in database")), l.lemma.get)))

    /** Retrieves lemmas identified by `lemmaIds` in bulk. */
    private[SQLite] def getLemmas(lemmaIds: List[Int]): Option[List[(Int, String)]] = synchronizedTransaction({
      if (lemmaIds.size > 1) {
        //@todo Code Review: This code should be revised to either select in SQL land from lemmaIds, or read all and filter, or read individual ones in a single transaction
        //@todo Code Review: for lemmas that are in lemmaIds, assert not None, for all other lemmas, filter them out instead of converting to empty string
        //@fix: revised to use inSetBind (results in a query SELECT from Lemmas WHERE _Id IN (...), keep l.lemma option, filter below
        val lemmaQuery = for {
          l <- Lemmas
          if l._Id.inSetBind(lemmaIds)
          if l.lemma.isDefined
        } yield (l._Id.getOrElse(throw new IllegalStateException("Lemma without ID stored in database")), l.lemma.get)
        try {
          //@todo Code Review: check that lemmaIds really should not have "" names now
          //@fix: implement LemmaDB contract right here
          val lemmas = lemmaQuery.list
          if (lemmas.size != lemmaIds.size) None
          else Some(lemmas)
        } catch {
          case _: Exception => None
        }
      } else if (lemmaIds.size == 1) {
        Some(lemmaQuery(lemmaIds.head).list)
      } else Some(Nil)
    })

    /** Deletes the lemma identified by `lemmaId` from the database. */
    private[SQLite] def deleteLemma(lemmaId: Int): Unit = synchronizedTransaction({
      // check that it deleted exactly one row
      val deletedEntries = Lemmas.filter(_._Id === lemmaId).delete
      assert(deletedEntries == 1, "deleting one identifier should delete one entry")
    })

    /** Clears all lemmas from the database. */
    private[SQLite] def deleteAllLemmas(): Unit = synchronizedTransaction(Lemmas.delete)

    //</editor-fold>

    //<editor-fold desc="Configuration storage">

    /** @inheritdoc */
    final override def getAllConfigurations: Set[ConfigurationPOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      Config.list.filter(_.configname.isDefined).map(_.configname.get).map(getConfiguration).toSet
    })

    /**
      * Poorly named -- either update the config, or else insert an existing key.
      * But in Mongo it was just update, because of the nested documents thing.
      *
      * @param config The new configuration.
      */
    final override def updateConfiguration(config: ConfigurationPOJO): Unit = synchronizedTransaction({
      config.config.foreach(kvp => {
        val key = kvp._1
        val value = kvp._2
        nSelects = nSelects + 1
        val configExists = Config.filter(c => c.configname === config.name && c.key === key).exists.run

        if (configExists) {
          val q = for {l <- Config if l.configname === config.name && l.key === key} yield l.value
          q.update(Some(value))
          nUpdates = nUpdates + 1
        } else {
          Config.map(c => (c.configname.get, c.key.get, c.value.get)).insert((config.name, key, value))
          nInserts = nInserts + 1
        }
      })
    })

    /** @inheritdoc */
    final override def getConfiguration(configName: String): ConfigurationPOJO = synchronizedTransaction({
      nSelects = nSelects + 1
      val kvp = Config.filter(_.configname === configName)
        .filter(_.key.isDefined)
        .list
        .map(conf => (conf.key.get, conf.value.getOrElse("")))
        .toMap
      new ConfigurationPOJO(configName, kvp)
    })

    private def configWithDefault(config: String, subconfig: String, default: Int): Int = try {
      getConfiguration(config).config(subconfig).toInt
    } catch {
      case _: NoSuchElementException => default
    }

    //</editor-fold>

    //<editor-fold desc="Model storage">

    /** @inheritdoc */
    final override def getModelList(userId: String): List[ModelPOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      Models.filter(_.userid === userId).list.map(element => new ModelPOJO(element._Id.get, element.userid.get,
        element.name.get, element.date.getOrElse(""), element.filecontents.getOrElse(""),
        element.description.getOrElse(""), element.publink.getOrElse(""), element.title.getOrElse(""), element.tactic,
        getNumAllProofSteps(element._Id.get), element.istemporary.getOrElse(0) == 1))
    })

    /** @inheritdoc */
    final override def getUniqueModelName(userId: String, modelName: String): String = {
      val models = Models.filter(_.userid === userId).filter(_.name.startsWith(modelName)).map(_.name).list
      if (models.isEmpty) modelName
      else {
        val max = (0 :: models.filter(_.isDefined).map(s =>
          Try(s.get.substring(modelName.length).trim().stripPrefix("(").stripSuffix(")").toInt).toOption).
          filter(_.isDefined).map(_.get)).max
        s"$modelName (${max+1})"
      }
    }

    /** @inheritdoc */
    final override def createModel(userId: String, name: String, fileContents: String, date: String,
                                   description: Option[String] = None, publink: Option[String] = None,
                                   title: Option[String] = None, tactic: Option[String] = None): Option[Int] =
      synchronizedTransaction({
        nSelects = nSelects + 1
        if (Models.filter(_.userid === userId).filter(_.name === name).list.isEmpty) {
          nInserts = nInserts + 1
          Some((Models.map(m => (m.userid.get, m.name.get, m.filecontents.get, m.date.get, m.description, m.publink, m.title, m.tactic))
            returning Models.map(_._Id.get))
            .insert(userId, name, fileContents, date, description, publink, title, tactic))
        }
        else None
      })

    /** @inheritdoc */
    final override def updateModel(modelId: Int, name: String, title: Option[String], description: Option[String],
                                   content: Option[String], tactic: Option[String]): Unit = synchronizedTransaction({
      assert(Models.filter(m => m._Id === modelId && m.filecontents === content).exists.run
        || Proofs.innerJoin(Executionsteps).on((proofs, steps) => steps.proofid === proofs._Id).
        filter({ case (proofs, _) => proofs.modelid === modelId }).length.run <= 0, "Updating model content only possible for models without proof steps")
      Models.filter(_._Id === modelId).
        map(m => (m.name, m.title, m.description, m.filecontents, m.tactic)).
        update(Some(name), title, description, content, tactic)
      nUpdates = nUpdates + 1
    })

    /** @inheritdoc */
    final override def addModelTactic(modelId: String, fileContents: String): Option[Int] = synchronizedTransaction({
      nSelects = nSelects + 1
      val mId = Integer.parseInt(modelId)
      if (Models.filter(_._Id === mId).filter(_.tactic.isEmpty).list.isEmpty) {
        Some(Models.filter(_._Id === mId).map(_.tactic).update(Some(fileContents)))
      } else None
    })

    /** @inheritdoc */
    final override def getModel(modelId: Int): ModelPOJO = synchronizedTransaction({
      nSelects = nSelects + 1
      val models =
        Models.filter(_._Id === modelId)
          .list
          .map(m => new ModelPOJO(
            m._Id.get, m.userid.get, m.name.getOrElse(""), m.date.getOrElse(""), m.filecontents.get, m.description.getOrElse(""),
            m.publink.getOrElse(""), m.title.getOrElse(""), m.tactic, getNumAllProofSteps(m._Id.get), m.istemporary.getOrElse(0) == 1
          ))
      if (models.length < 1) throw new Exception("getModel type should be an Option")
      else if (models.length == 1) models.head
      else throw new Exception("Primary keys aren't unique in models table.")
    })

    /** @inheritdoc */
    final override def deleteModel(modelId: Int): Boolean = synchronizedTransaction({
      Models.filter(_._Id === modelId).delete
      Proofs.filter(_.modelid === modelId).list.map(prf => deleteProof(prf._Id.get))
      true
    })

    /** @inheritdoc */
    final override def getInvariants(modelId: Int): Map[Expression, Formula] = {
      val model = getModel(modelId)
      var invariants: Map[Expression, Formula] = Map.empty
      Parser.parser.setAnnotationListener{case (program, formula) =>
        invariants = invariants.+((program, formula))
      }
      ArchiveParser.parseAsFormula(model.keyFile)
      invariants
    }

    //</editor-fold>

    //<editor-fold desc="User storage">

    /** @inheritdoc */
    final override def createUser(username: String, password: String, mode: String): Unit = {
      /* Store passwords as a salted hash. Allow configuring number of iterations
       * since we may conceivably want to change it after deployment for performance reasons */
      val iterations = configWithDefault("security", "passwordHashIterations", 10000)
      val saltLength = configWithDefault("security", "passwordSaltLength", 512)
      val (hash, salt) = Password.generateKey(password, iterations, saltLength)
      synchronizedTransaction({
        Users.map(u => (u.email.get, u.hash.get, u.salt.get, u.iterations.get, u.level.get))
          .insert((username, hash, salt, iterations, Integer.parseInt(mode)))
        nInserts = nInserts + 1
      })}

    /** @inheritdoc */
    final override def userExists(username: String): Boolean = synchronizedTransaction({
      nSelects = nSelects + 1
      Users.filter(_.email === username).exists.run
    })

    /** @inheritdoc */
    final override def getUser(username: String): Option[UserPOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      val users =
        Users.filter(_.email === username)
          .list
          .map(m => new UserPOJO(m.email.get, m.level.get))
      if (users.length <= 1) users.headOption
      else throw new Exception("Primary keys aren't unique in models table.")
    })

    /** @inheritdoc */
    final override def checkPassword(username: String, password: String): Boolean = synchronizedTransaction({
      nSelects = nSelects + 1
      Users.filter(_.email === username).list.exists({row =>
        val hash = Password.hash(password.toCharArray, row.salt.get.getBytes("UTF-8"), row.iterations.get)
        Password.hashEquals(hash, row.hash.get)
      })
    })

    /** @inheritdoc */
    final override def getTempUsers: List[UserPOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      Users.filter(_.level === 3).list.map(m => new UserPOJO(m.email.get, m.level.get))
    })

    //</editor-fold>

    //<editor-fold desc="Proof storage">

    private[this] def getNumAllProofSteps(modelId: Int): Int = {
      Proofs.innerJoin(Executionsteps).on((proofs, steps) => steps.proofid === proofs._Id).
        filter({ case (proofs, _) => proofs.modelid === modelId }).length.run
    }

    private[this] lazy val proofClosedQuery = Compiled((proofId: Column[Int]) =>
      Proofs.filter(p => p._Id === proofId && p.closed.getOrElse(0) === 1).exists)

    /** @inheritdoc */
    final override def isProofClosed(proofId: Int): Boolean = synchronizedTransaction({
      proofClosedQuery(proofId).run
    })

    private[this] lazy val stepCountQuery = Compiled((proofId: Column[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)).map(_._Id).countDistinct)

    final override def proofExists(proofId: Int): Boolean = synchronizedTransaction({
      Proofs.filter(_._Id === proofId).list.nonEmpty
    })

    /** @inheritdoc */
    final override def getProofInfo(proofId: Int): ProofPOJO = synchronizedTransaction({
      val stepCount = stepCountQuery(proofId).run
      nSelects = nSelects + 1
      val q = for { p <- Proofs if p._Id === proofId } yield (p.modelid, p.lemmaid)
      q.run.headOption match {
        case Some((modelId, lemmaId)) =>
          if (lemmaId.isEmpty) {
            val (lemmaId, _) = initializeProofForModel(modelId.get, None)
            q.update(modelId, Some(lemmaId))
          }

          val list = Proofs.filter(_._Id === proofId)
            .list
            .map(p => ProofPOJO(p._Id.get, p.modelid, p.name.getOrElse(""), p.description.getOrElse(""),
              p.date.getOrElse(""), stepCount, p.closed.getOrElse(0) == 1, p.lemmaid, p.istemporary.getOrElse(0) == 1, p.tactic))
          if (list.length > 1) throw new IllegalStateException("Duplicate proof " + proofId)
          else if (list.isEmpty) throw new IllegalStateException("Proof not found: " + proofId)
          else list.head
        case None => throw new IllegalStateException("Proof not found: " + proofId)
      }
    })

    /** @inheritdoc */
    final override def getProofsForUser(userId: String): List[(ProofPOJO, String)] = synchronizedTransaction({
      val models = getModelList(userId)

      models.flatMap(model => {
        val modelName = model.name
        val proofs = getProofsForModel(model.modelId)
        proofs.map((_, modelName))
      })
    })

    private lazy val userOwnsProofQuery = Compiled((userId: Column[String], proofId: Column[Int]) => {
      (for {
        p <- Proofs.filter(_._Id === proofId)
        m <- Models.filter(_.userid === userId) if m._Id === p.modelid
      } yield p._Id).exists
    })

    /** @inheritdoc */
    final override def userOwnsProof(userId: String, proofId: String): Boolean = synchronizedTransaction({
      userOwnsProofQuery(userId, proofId.toInt).run
    })

    /** @inheritdoc */
    final override def updateProofInfo(proof: ProofPOJO): Unit =
      synchronizedTransaction({
        nSelects = nSelects + 1
        Proofs.filter(_._Id === proof.proofId).update(proofPojoToRow(proof))
        nUpdates = nUpdates + 1
      })

    /** Converts the proof meta information into database format. */
    private[this] def proofPojoToRow(p: ProofPOJO): ProofsRow =
      ProofsRow(_Id = Some(p.proofId), modelid = p.modelId, name = Some(p.name),
        description = Some(p.description), date =Some(p.date), closed = Some(if (p.closed) 1 else 0),
        lemmaid = p.provableId, istemporary = Some(if (p.temporary) 1 else 0), tactic = p.tactic
      )

    /** @inheritdoc */
    final override def getProofsForModel(modelId: Int): List[ProofPOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      Proofs.filter(_.modelid === modelId).list.map(p => {
        val stepCount = stepCountQuery(p._Id.get).run //@todo avoid ripple loading
        val closed: Boolean = sqliteBoolToBoolean(p.closed.getOrElse(0))
        val temporary: Boolean = sqliteBoolToBoolean(p.istemporary.getOrElse(0))
        ProofPOJO(p._Id.get, p.modelid, p.name.getOrElse(""), p.description.getOrElse(""), p.date.getOrElse(""), stepCount,
          closed, p.lemmaid, temporary, p.tactic)
      })
    })

    /** @inheritdoc */
    final override def deleteProofSteps(proofId: Int): Int = synchronizedTransaction({
      val countBefore = stepCountQuery(proofId).run
      //@note count returned from .delete does not reflect the number of deleted steps correctly
      Executionsteps.filter(_.proofid === proofId).delete
      val countAfter = stepCountQuery(proofId).run
      //@note deleting all steps, no need to update subgoal count
      val q = for { proof <- Proofs if proof._Id === proofId } yield (proof.closed, proof.lemmaid)
      val (_, lemmaid) = q.run.head
      // delete associated lemma
      Lemmas.filter(_._Id === lemmaid).delete
      // reset closed flag and initial lemma
      q.update(Some(0), None)
      countBefore-countAfter
    })

    /** @inheritdoc */
    final override def deleteProof(proofId: Int): Boolean = synchronizedTransaction({
      deleteProofSteps(proofId)
      Proofs.filter(x => x._Id === proofId).delete == 1
    })

    /** Initializes the proof by creating a provable from the model, returns the provable ID and optional substituted tactic. */
    private[this] def initializeProofForModel(modelId: Int, tactic: Option[String]): (Int, Option[String]) = {
      val model = getModel(modelId)
      val entry = ArchiveParser.parseProblem(model.keyFile, parseTactics=false)
      val d = entry.defs
      val problem = entry.model.asInstanceOf[Formula]

      val substTactic = tactic match {
        case None => None
        case Some(t) => Some(BellePrettyPrinter(ArchiveParser.tacticParser(t)))
      }

      val provable = ProvableSig.startProof(problem, d)
      (createProvable(provable), substTactic)
    }

    /** @inheritdoc */
    final override def createProofForModel(modelId: Int, name: String, description: String, date: String,
                                           tactic: Option[String]): Int = synchronizedTransaction({
      nInserts = nInserts + 2
      val (provableId, substTactic) = initializeProofForModel(modelId, tactic)
      val proofId =
        (Proofs.map(p => ( p.modelid.get, p.name.get, p.description.get, p.date.get, p.closed.get, p.lemmaid.get,
          p.istemporary.get, p.tactic))
          returning Proofs.map(_._Id.get))
          .insert(modelId, name, description, date, 0, provableId, 0, substTactic)

      proofId
    })

    /** @inheritdoc */
    final override def createProof(provable: ProvableSig): Int = synchronizedTransaction({
      nInserts = nInserts + 3
      val provableId = createProvable(provable)
      val proofId =
        (Proofs.map(p => ( p.closed.get, p.lemmaid.get, p.istemporary.get))
          returning Proofs.map(_._Id.get))
          .insert(0, provableId, 1)

      //      val executableId = addBelleExpr(TactixLibrary.nil)
      //      addExecutionStep(ExecutionStepPOJO(None, proofId, None, None, Some(0), None, 0,
      //        ExecutionStepStatus.Finished, executableId, None, None, Some(provableId), userExecuted=false, "start"))

      proofId
    })

    /** @inheritdoc */
    final override def deleteProvable(provableId: Int): Boolean = ???

    /** @inheritdoc */
    final override def addExecutionStep(step: ExecutionStepPOJO): Int = synchronizedTransaction({
      val status = ExecutionStepStatus.toString(step.status)
      val steps =
        Executionsteps.map(dbstep => (dbstep.proofid.get, dbstep.previousstep,
          dbstep.branchorder, dbstep.status.get, dbstep.executableid.get,
          dbstep.inputprovableid, dbstep.resultprovableid, dbstep.localprovableid, dbstep.userexecuted.get, dbstep.childrenrecorded.get,
          dbstep.rulename.get)
        ) returning Executionsteps.map(_._Id.get)
      val stepId = steps
        .insert((step.executionId, step.previousStep, step.branchOrder,
          status, step.executableId, step.inputProvableId, step.resultProvableId,
          step.localProvableId, step.userExecuted.toString, false.toString, step.ruleName))

      updateOpenSubgoalsCount(step.executionId, step.previousStep)

      nInserts = nInserts + 1
      stepId
    })

    /** @inheritdoc */
    final override def addAlternative(alternativeTo: Int, inputProvable: ProvableSig, trace: ExecutionTrace): Unit = {
      //      def get(stepId: Int) = {
      //        Executionsteps.filter(_._Id === stepId).list match {
      //          case Nil => throw new Exception("Execution step not found")
      //          case step :: _ => step
      //        }
      //      }
      //      val oldStep = get(alternativeTo)
      //      def addSteps(prev: Option[Int], globalProvable:ProvableSig, steps:List[ExecutionStep]): Unit = {
      //        if (steps.nonEmpty) {
      //          val thisStep = steps.head
      //          val thisPOJO = get(thisStep.stepId)
      //          val localProvable = getProvable(thisPOJO.localprovableid.get).provable
      //          val outputProvable = globalProvable(localProvable, thisStep.branch)
      //          val newStep = ExecutionStepPOJO(None, oldStep.executionid.get, prev, None, Some(thisStep.branch),
      //            None, oldStep.alternativeorder.get + 1, ExecutionStepStatus.fromString(thisPOJO.status.get), thisPOJO.executableid.get,
      //            None, None, thisPOJO.localprovableid, thisPOJO.userexecuted.get.toBoolean, thisPOJO.rulename.get, localProvable.subgoals.size)
      //          val newId = addExecutionStep(newStep)
      //          addSteps(Some(newId), outputProvable, steps.tail)
      //        }
      //      }
      //      if(trace.steps.isEmpty) {
      //        // Insert a null tactic with a higher alternative order
      //        val nilExecutable = addBelleExpr(TactixLibrary.nil)
      //        val localConclusion = inputProvable.subgoals(0)
      //        // Generate a no-op local provable whose conclusion matches with the current state of the proof.
      //        val localProvable = ProvableSig.startProof(localConclusion)
      //        val newLocalProvableID = createProvable(localProvable)
      //        val step = ExecutionStepPOJO(None, oldStep.executionid.get, oldStep.previousstep, None, Some(0), None,
      //          oldStep.alternativeorder.get + 1, ExecutionStepStatus.Finished, nilExecutable, oldStep.inputprovableid,
      //          oldStep.inputprovableid, Some(newLocalProvableID), userExecuted=false, "nil", localProvable.subgoals.size)
      //        addExecutionStep(step)
      //      } else {
      //        addSteps(oldStep.previousstep, inputProvable, trace.steps)
      //      }
    }

    /** @inheritdoc */
    final override def addBelleExpr(expr: BelleExpr): Int = synchronizedTransaction({
      val executableId =
        (Executables.map(_.belleexpr)
          returning Executables.map(_._Id.get))
          .insert(Some(BellePrettyPrinter(expr)))
      nInserts = nInserts + 1
      executableId
    })

    /** @inheritdoc */
    final override def createProvable(p: ProvableSig): Int = synchronizedTransaction({
      val lemma = Lemma(p, Lemma.requiredEvidence(p, List(ToolEvidence(List("input" -> p.prettyString, "output" -> "true")))))
      lemmaDB.add(lemma).toInt
    })

    /** @inheritdoc */
    final override def getExecutable(executableId: Int): ExecutablePOJO = getExecutables(List(executableId)).head

    /** Allow retrieving executables in bulk to reduce the number of database queries. */
    private[this] def getExecutables(executableIds: List[Int]): List[ExecutablePOJO] = synchronizedTransaction({
      nSelects = nSelects + 1
      val q = for {
        exe <- Executables
        if exe._Id inSetBind executableIds
      } yield (exe._Id.get, exe.belleexpr.get)
      val executableMap = q.run.map(exe => (exe._1, ExecutablePOJO(exe._1, exe._2))).toMap
      try {
        executableIds.map(executableMap)
      } catch {
        case _:Exception => throw new ProverException("getExecutable type should be an Option")
      }
    })

    /** @inheritdoc */
    final override def getProvable(lemmaId: Int): ProvablePOJO = loadProvables(List(lemmaId)).head

    private[this] def loadProvables(lemmaIds: List[Int]): List[ProvablePOJO] = {
      lemmaDB.get(lemmaIds.map(_.toString)) match {
        case None => throw new Exception(" No lemma for one of these IDs: " + lemmaIds)
        case Some(lemmas) => lemmas.zipWithIndex.map({case (lemma, id) => ProvablePOJO(id, lemma.fact)})
      }
    }

    /** @inheritdoc */
    final override def updateExecutionStep(executionStepId: Int, step: ExecutionStepPOJO): Unit = synchronizedTransaction({
      nSelects = nSelects + 1
      nUpdates = nUpdates + 1
      // update step
      Executionsteps.filter(_._Id === executionStepId)
        .map(dbstep => (dbstep.proofid.get, dbstep.previousstep,
          dbstep.branchorder, dbstep.status.get, dbstep.executableid.get,
          dbstep.inputprovableid, dbstep.resultprovableid, dbstep.localprovableid, dbstep.userexecuted.get, dbstep.childrenrecorded.get,
          dbstep.rulename.get, dbstep.numsubgoals, dbstep.numopensubgoals)
        ).update((step.executionId, step.previousStep, step.branchOrder,
        ExecutionStepStatus.toString(step.status), step.executableId, step.inputProvableId, step.resultProvableId,
        step.localProvableId, step.userExecuted.toString, false.toString,
        //@todo store branch labels separately
        step.ruleName + RULENAME_BRANCH_SEPARATOR + step.branchLabel.getOrElse(""),
        step.numSubgoals, step.numOpenSubgoals))

      // update parent's open subgoals
      updateOpenSubgoalsCount(step.executionId, step.previousStep)
    })

    private lazy val stepQuery = Compiled((proofId: Column[Int], stepId: Column[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).map(_.numsubgoals))

    private lazy val succStepCountQuery = Compiled((proofId: Column[Int], stepId: Column[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId &&
          row.previousstep === stepId &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)).map(_._Id).countDistinct)

    /** Recompute the open subgoals count of a step. */
    private[this] def updateOpenSubgoalsCount(proofId: Int, stepId: Option[Int]): Unit = {
      stepId match {
        case None => // nothing to do
        case Some(sId) =>
          val succStepsCount = succStepCountQuery(proofId, sId).run
          val totalSubgoals = stepQuery(proofId, sId).list.head
          //@note select+update is faster than increment/decrement numSubGoals column
          Executionsteps.filter(_._Id === sId).map(_.numopensubgoals).update(totalSubgoals - succStepsCount)
      }
    }

    private lazy val stepParentQuery = Compiled((proofId: Column[Int], stepId: Column[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).map(_.previousstep))

    /** @inheritdoc */
    final override def deleteExecutionStep(proofId: Int, stepId: Int): Unit = {
      //val succStepsQuery = Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId)
      val parent = stepParentQuery(proofId, stepId).list.head
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId).delete
      updateOpenSubgoalsCount(proofId, parent)
    }

    private lazy val executionStepsQuery = Compiled((proofId: Column[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId &&
        row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)).
        sortBy(e => (e.previousstep.asc, e.branchorder.desc)))

    private[this] def proofSteps(executionId: Int): List[ExecutionStepPOJO] = synchronizedTransaction({
      /* The Executionsteps table may contain many alternate histories for the same execution. In order to reconstruct
       * the current state of the world, we must pick the most recent alternative at every opportunity.*/
      var steps = executionStepsQuery(executionId).run
      val prevIds: scala.collection.mutable.Stack[Option[Int]] = new scala.collection.mutable.Stack()
      prevIds.push(None)
      var revResult: List[ExecutionStepPOJO] = Nil
      while (prevIds.nonEmpty) {
        val prevId = prevIds.top
        val (headSteps, tailSteps) = steps.partition(_.previousstep == prevId)
        if (headSteps.nonEmpty) {
          val head = headSteps.head
          val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(head.rulename.get)
          revResult =
            ExecutionStepPOJO(head._Id, head.proofid.get, head.previousstep,
              head.branchorder, ExecutionStepStatus.fromString(head.status.get),
              head.executableid.get, head.inputprovableid, head.resultprovableid, head.localprovableid, head.userexecuted.get.toBoolean,
              ruleName, branchLabel, head.numsubgoals, head.numopensubgoals) :: revResult
          if (headSteps.tail.isEmpty) prevIds.pop
          prevIds.push(head._Id)
          steps = headSteps.tail ++ tailSteps
        } else {
          prevIds.pop
          steps = tailSteps
        }
      }
      revResult.reverse
    })

    /** Zips execution steps with auxiliary information (executable tactics, provables). */
    private[this] def zipTrace(executionSteps: List[ExecutionStepPOJO],
                               provables: Option[(ProvableSig, Map[Option[Int], ProvableSig])]): List[ExecutionStep] = {
      executionSteps match {
        case step::steps =>
          val localProvable: () => ProvableSig = provables match {
            case None => () => getProvable(step.localProvableId.get).provable
            case Some((rootProvable, localProvables)) =>
              val localProvable = localProvables(step.stepId)
              val inputProvable = step.previousStep match {
                case prevId@Some(_) => localProvables(prevId)
                case None => rootProvable
              }
              assert(step.branchOrder < inputProvable.subgoals.size, "Open branch index " + step.branchOrder +
                " should point to a subgoal, but got only " + inputProvable.subgoals.size + " subgoals:\n" +
                inputProvable.subgoals.map(_.prettyString).mkString("\n"))
              assert(inputProvable.subgoals(step.branchOrder) == localProvable.conclusion,
                "Conclusion of subderivation " + localProvable.conclusion +
                  " should match open goal " + inputProvable.subgoals(step.branchOrder) +
                  " (subgoal " + step.branchOrder + ")")
              () => localProvable
          }
          val successorIds = steps.filter(_.previousStep == step.stepId).map(_.stepId.get)
          ExecutionStep(step.stepId.get, step.previousStep, step.executionId, localProvable,
            step.branchOrder, step.numSubgoals, step.numOpenSubgoals, successorIds, step.ruleName, step.executableId,
            step.userExecuted)  ::
            zipTrace(steps, provables)
        case Nil => Nil
        case _ => throw new ProverException("Bug in zipTrace")
      }
    }

    /** @inheritdoc */
    final override def getExecutionSteps(executionId: Int): List[ExecutionStepPOJO] = proofSteps(executionId)

    private lazy val firstExecutionStepQuery = Compiled((proofId: Column[Int]) =>
      Executionsteps.filter(
        row => row.proofid === proofId &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished) &&
          row.previousstep.isEmpty
      ))

    /** @inheritdoc */
    final override def getFirstExecutionStep(proofId: Int): Option[ExecutionStepPOJO] =
      firstExecutionStepQuery(proofId).list.headOption.map(step => {
        val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
        ExecutionStepPOJO(step._Id, step.proofid.get, step.previousstep,
          step.branchorder, ExecutionStepStatus.fromString(step.status.get),
          step.executableid.get, step.inputprovableid, step.resultprovableid, step.localprovableid,
          step.userexecuted.get.toBoolean, ruleName, branchLabel, step.numsubgoals, step.numopensubgoals)
      })

    //</editor-fold>

    //<editor-fold desc="Proof agenda">

    /** @inheritdoc */
    final override def addAgendaItem(proofId: Int, initialProofNode: ProofTreeNodeId, displayName:String): Int = synchronizedTransaction({
      val (stepId, subgoalId) = tupleId(initialProofNode)
      (Agendaitems.map(item => (item.proofid.get, item.stepid, item.subgoalid, item.displayname.get))
        returning Agendaitems.map(_._Id.get))
        .insert(proofId, stepId, subgoalId, displayName)
    })

    /** @inheritdoc */
    final override def updateAgendaItem(item:AgendaItemPOJO): Unit = synchronizedTransaction({
      val (stepId, subgoalId) = tupleId(item.initialProofNode)
      Agendaitems.filter(_._Id === item.itemId)
        .map(dbitem => (dbitem.proofid.get, dbitem.stepid, dbitem.subgoalid, dbitem.displayname.get))
        .update((item.proofId, stepId, subgoalId, item.displayName))
    })

    /** @inheritdoc */
    final override def agendaItemsForProof(proofId: Int): List[AgendaItemPOJO] = {
      synchronizedTransaction({
        Agendaitems.filter(_.proofid === proofId)
          .list
          .map(item => AgendaItemPOJO(item._Id.get, item.proofid.get, DbStepPathNodeId(item.stepid, item.subgoalid), item.displayname.get))
      })
    }

    /** @inheritdoc */
    final override def getAgendaItem(proofId: Int, initialProofNode: ProofTreeNodeId): Option[AgendaItemPOJO] = {
      val (stepId, subgoalId) = tupleId(initialProofNode)
      synchronizedTransaction({
        Agendaitems.filter{row => row.proofid === proofId && row.stepid === stepId && row.subgoalid === subgoalId}
          .list
          .map(item => AgendaItemPOJO(item._Id.get, item.proofid.get, DbStepPathNodeId(item.stepid, item.subgoalid), item.displayname.get))
          .headOption
      })
    }

    //</editor-fold>

    //<editor-fold desc="Proof tree">

    /** Turns the proof node `id` into a tuple. */
    private def tupleId(id: ProofTreeNodeId): (Option[Int], Option[Int]) = id match {
      case DbStepPathNodeId(step, branch) => (step, branch)
    }

    private lazy val openStepsQuery = Compiled((proofId: Column[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId &&
          row.numopensubgoals > 0 &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)))

    private lazy val leavesQuery = Compiled((proofId: Column[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId &&
          (row.numsubgoals === 0 || row.numopensubgoals > 0) &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)))

    // performance degrades a little with increasing database volume
    private def closedBranchesSql(proofId: Int, openSteps: Set[Int]) =
      sql"""SELECT previousStep,group_concat(branchOrder) FROM executionSteps WHERE proofId=$proofId AND status='Finished' AND previousStep IN (#${openSteps.mkString(",")}) GROUP BY previousStep""".as[(Int,String)]

    private def getPlainFinishedSteps(proofId: Int, steps: List[Executionsteps#TableElementType]): List[(ExecutionStepPOJO, List[Int])] = synchronizedTransaction({
      val stepsPOJOs = steps.map(step => {
        val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
        ExecutionStepPOJO(step._Id, step.proofid.get, step.previousstep,
          step.branchorder, ExecutionStepStatus.fromString(step.status.get),
          step.executableid.get, step.inputprovableid, step.resultprovableid, step.localprovableid,
          step.userexecuted.get.toBoolean, ruleName, branchLabel, step.numsubgoals, step.numopensubgoals)
      })
      val closedBranches = closedBranchesSql(proofId, stepsPOJOs.flatMap(_.stepId).toSet).list.toMap

      def parseClosedBranches(closed: Option[String]): List[Int] = closed match {
        case None => Nil
        case Some(s) => s.split(",").map(_.toInt).toList
      }

      stepsPOJOs.map(s => (s, parseClosedBranches(closedBranches.get(s.stepId.get))))
    })

    /** @inheritdoc */
    final override def getPlainOpenSteps(proofId: Int): List[(ExecutionStepPOJO,List[Int])] = getPlainFinishedSteps(proofId, openStepsQuery(proofId).list)

    /** @inheritdoc */
    final override def getPlainLeafSteps(proofId: Int): List[(ExecutionStepPOJO, List[Int])] = getPlainFinishedSteps(proofId, leavesQuery(proofId).list)

    private lazy val executionStepQuery = Compiled((proofId: Column[Int], stepId: Column[Int]) =>
      Executionsteps.filter(row => row.proofid === proofId && row._Id === stepId &&
        row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)))

    /** @inheritdoc */
    final override def getPlainExecutionStep(proofId: Int, stepId: Int): Option[ExecutionStepPOJO] = {
      executionStepQuery(proofId, stepId).run.headOption match {
        case None => None
        case Some(step) =>
          val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
          Some(ExecutionStepPOJO(step._Id, step.proofid.get, step.previousstep,
            step.branchorder, ExecutionStepStatus.fromString(step.status.get),
            step.executableid.get, step.inputprovableid, step.resultprovableid, step.localprovableid,
            step.userexecuted.get.toBoolean, ruleName, branchLabel, step.numsubgoals, step.numopensubgoals))
      }
    }

    private lazy val stepSuccessorsQuery = Compiled((proofId: Column[Int], prevStepId: Column[Int], branchOrder: Column[Int]) =>
      Executionsteps.filter(row =>
        row.proofid === proofId &&
          row.previousstep === prevStepId &&
          row.branchorder === branchOrder &&
          row.status === ExecutionStepStatus.toString(ExecutionStepStatus.Finished)))

    /** @inheritdoc */
    final override def getPlainStepSuccessors(proofId: Int, prevStepId: Int, branchOrder: Int): List[ExecutionStepPOJO] = {
      stepSuccessorsQuery(proofId, prevStepId, branchOrder).run.map(step => {
        val (ruleName: String, branchLabel: Option[String]) = splitNameLabel(step.rulename.get)
        ExecutionStepPOJO(step._Id, step.proofid.get, step.previousstep,
          step.branchorder, ExecutionStepStatus.fromString(step.status.get),
          step.executableid.get, step.inputprovableid, step.resultprovableid, step.localprovableid,
          step.userexecuted.get.toBoolean, ruleName, branchLabel, step.numsubgoals, step.numopensubgoals)
      }).toList
    }

    /** @inheritdoc */
    final override def getExecutionStep(proofId: Int, stepId: Int): Option[ExecutionStep] = getPlainExecutionStep(proofId, stepId) match {
      case None => None
      case Some(step) =>
        val localProvable = getProvable(step.localProvableId.get).provable
        //@todo extend getPlainExecutionStep to query for successor IDs right away
        val successorIds = getExecutionSteps(proofId).filter(_.previousStep == step.stepId).map(_.stepId.get)
        Some(ExecutionStep(step.stepId.get, step.previousStep, step.executionId, () => localProvable,
          step.branchOrder, step.numSubgoals, step.numOpenSubgoals, successorIds, step.ruleName, step.executableId,
          step.userExecuted))
    }

    /** @inheritdoc */
    final override def getStepProvable(proofId: Int, stepId: Option[Int], subgoal: Option[Int]): Option[ProvableSig] = (stepId, subgoal) match {
      case (None, None) => getProofInfo(proofId).provableId match {
        case None => None
        case Some(pId) => Some(getProvable(pId).provable)
      }
      case (Some(stId), None) => getPlainExecutionStep(proofId, stId) match {
        case Some(step) => step.localProvableId match {case None => None case Some(lpId) => Some(getProvable(lpId).provable)}
        case None => throw new IllegalArgumentException("Unknown step ID " + stId)
      }
      case (stId, Some(sgIdx)) => getStepProvable(proofId, stId, None) match {
        case None => None
        case Some(p) => Some(p.sub(sgIdx))
      }
    }

    /** @inheritdoc */
    final override def getExecutionTrace(proofId: Int, withProvables: Boolean=true): ExecutionTrace = {
      /* This method has proven itself to be a resource hog, so this implementation attempts to minimize the number of
         DB calls. */
      val stepsCount = stepCountQuery(proofId).run
      if (stepsCount <= 0) {
        ExecutionTrace(proofId.toString, proofId.toString, Nil)
      } else {
        //@todo sqlite has a maximum of 999 variables in a query (could be changed, but any number might be too small)
        // -> may need to query steps and provables joined, but how to benefit from cached lemma DB then?
        val steps = proofSteps(proofId)
        val provables = if (withProvables) {
          val provableIds = steps.map(_.localProvableId.get)
          val provables = steps.map(_.stepId).zip(loadProvables(provableIds).map(_.provable)).toMap
          val conclusion = provables(steps.head.stepId).conclusion
          val initProvable = ProvableSig.startPlainProof(conclusion)
          Some((initProvable, provables))
        } else None
        val traceSteps = zipTrace(steps, provables)
        ExecutionTrace(proofId.toString, proofId.toString, traceSteps)
      }
    }

    //</editor-fold>

  }
}
