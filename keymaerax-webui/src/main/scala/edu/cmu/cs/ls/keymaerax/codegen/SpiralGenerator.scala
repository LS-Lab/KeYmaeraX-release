/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import com.wolfram.jlink.Expr
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.launcher.DefaultConfiguration
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXPrettyPrinter
import edu.cmu.cs.ls.keymaerax.tools.{KeYmaeraToMathematica, JLinkMathematicaLink, MathematicaToKeYmaera}

import scala.collection.immutable.Map

/**
 * Created by ran on 7/3/15.
 * @author Ran Ji
 */

/**
 * Hcol file consists of
 *  - monitor (.g): constant table + monitor
 *  - header (.h): coefficients vectors
 */
class Hcol {
  private var constTbl : String = ""
  private var monitor : String  = ""
  private var coeffs : String = ""

  def getConstTbl = this.constTbl
  def setConstTbl(ct : String) = this.constTbl = ct
  def getMonitor = this.monitor
  def setMonitor(mnt : String) = this.monitor = mnt
  def getCoefficients = this.coeffs
  def setCoefficients(ceh : String) = this.coeffs = ceh
}

object SpiralGenerator extends CodeGenerator {
  def apply(kExpr: Expression): String = apply(kExpr, Nil, "")._1
  def apply(kExpr: Expression, fileName: String) : String = apply(kExpr, Nil, fileName)._1
  def apply(kExpr: Expression, vars: List[Variable], fileName: String): (String, String) = generateSpiralMonitor(kExpr, vars, fileName, false)
  def apply(kExpr: Expression, vars: List[Variable], fileName: String, dnfMode: Boolean): (String, String) = generateSpiralMonitor(kExpr, vars, fileName, dnfMode)

  private val hcol = new Hcol

  /** Mathematica settings */
  private val mathematicaConfig: Map[String, String] = DefaultConfiguration.defaultMathematicaConfig
  private val link : JLinkMathematicaLink= new JLinkMathematicaLink()
  link.init(mathematicaConfig.apply(mathematicaConfig.keys.head), None)

  /** Name counter used for generating new vector names */
  private var vecNameCounter : Int = 0

  /**
   * A list of encountered polynomial term and the corresponding generated Spiral code pair,
   * which is used to avoid generating Spiral code for the same  polynomial term multiple times
   */
  private var encounteredPolyTerm: List[(Term, String)] = Nil

  /** printings for monitor generation */
  private def infoG(fileName: String) =
    "# *************************\n" +
      {if(fileName.nonEmpty) "# " + fileName + ".g\n" + "# \n" else "" } +
      "# Generated by KeYmaera X\n" +
      "# *************************\n"
  private val libs = "# imports\n" +
//    "Import(spl, formgen, code, rewrite, transforms, search, compiler, sigma, platforms, platforms.sse, paradigms.common, paradigms.vector, paradigms.cache, libgen, backend);\n" +
    "ImportAll(packages.hacms);\n" +
    "ImportAll(paradigms.vector);\n\n"
  private val monDec = "# monitor\n" +
    "t := \n"

  /** Printings for coefficientHex generation */
  private def infoH(fileName: String) =
    "/**************************\n" +
      {if(fileName.nonEmpty) " * " + fileName + ".h\n" + " * \n" else "" } +
      " * Generated by KeYmaera X\n" +
      " **************************/\n\n"
  private def ifnDef(fileName: String) = "#ifndef _" + {if(fileName.nonEmpty) fileName.toUpperCase else "VECTOR"} + "_H_\n"
  private def define(fileName: String) = "#define _" + {if(fileName.nonEmpty) fileName.toUpperCase else "VECTOR"} + "_H_\n"
  private val endIf = "#endif"

  /**
   * Generate Spiral monitor
   *
   * @param kExpr     KeYmaera X arithmetic expression got from modelPlex
   * @param vars      a list of variables
   * @param fileName  file name
   * @return          .g code and .h code
   */
  def generateSpiralMonitor(kExpr: Expression, vars: List[Variable], fileName: String, dnfMode: Boolean) : (String, String) = {
    val names = StaticSemantics.symbols(kExpr).toList.map(s => nameIdentifier(s))
    require(names.distinct.size == names.size, "Expect unique name_index identifiers for code generation")
    // if the variable list is not empty, generate polynomial form, otherwise generate explicit form 
    val polynomialMode = vars.nonEmpty
    val sortedRlvtVars = getSortedRelevantVars(kExpr, vars)
    val spiralMonitor = if(dnfMode) compileMathDnfToSpiral(convertToDnf(kExpr), sortedRlvtVars) else compileToSpiral(kExpr, sortedRlvtVars)
    hcol.setMonitor(spiralMonitor)
    val gCode = infoG(fileName) + libs + {if(polynomialMode) "# declare constant table\n" + hcol.getConstTbl + "\n" else ""} + monDec + hcol.getMonitor + "\n;\n"
    val hCode =
      if(polynomialMode) infoH(fileName) + ifnDef(fileName) + define(fileName) + hcol.getCoefficients + endIf
      else ""
    (gCode, hCode)
  }

  /**
   * Get a list of alphabetically sorted variables relevant to (occur in) the given expression
   *
   * @param e     expression
   * @param vars  list of variables
   * @return      a list of sorted variables relevant to e
   */
  private def getSortedRelevantVars(e: Expression, vars: List[Variable]) : List[Variable] = {
    val allSortedNames = StaticSemantics.symbols(e).toList.sorted
    var sortedRelevantVars = List[Variable]()
    for(i <- vars.indices) {
      if(allSortedNames.contains(vars.apply(i)))
      // variable occurs in the expression, add it to the return list
        sortedRelevantVars = vars.apply(i) :: sortedRelevantVars
      if(allSortedNames.contains(Function(nameIdentifier(vars.apply(i)), None, Unit, Real)))
      // variable occur as nullary function, add it to the return list as a variable
        sortedRelevantVars = Variable(nameIdentifier(vars.apply(i))) :: sortedRelevantVars
      if(allSortedNames.contains(Variable(getPostNameIdentifier(vars.apply(i)))))
      // post variable occurs in the expression as variable, add it to the return list as a variable
        sortedRelevantVars = Variable(getPostNameIdentifier(vars.apply(i))) :: sortedRelevantVars
      if(allSortedNames.contains(Function(getPostNameIdentifier(vars.apply(i)), None, Unit, Real)))
      // post variable occurs in the expression as nullary function, add it to the return list as a variable
        sortedRelevantVars = Variable(getPostNameIdentifier(vars.apply(i))) :: sortedRelevantVars
    }
    assert(sortedRelevantVars.distinct.size == sortedRelevantVars.size,
      "Duplicated name_index identifiers found in {" + sortedRelevantVars.map(v => KeYmaeraXPrettyPrinter(v)).mkString(", ") + "}")
    sortedRelevantVars.sortWith(_.toString < _.toString)
  }

  /** Spiral Identifier corresponding to a NamedSymbol */
  private def nameIdentifier(s: NamedSymbol): String = {
    require(s.isInstanceOf[Function] || s.isInstanceOf[Variable] || s.isInstanceOf[DifferentialSymbol])
    require(s.sort == Real, "only real-valued symbols are currently supported")
    s match {
      case DifferentialSymbol(x) => nameIdentifier(x) + "__p"
      case _ => if (s.index.isEmpty) s.name else s.name + "_" + s.index.get
    }
  }

  /** Get the post variable name identifier */
  private def getPostNameIdentifier(v: Variable): String = if (v.index.isEmpty) v.name + "post" else v.name + "post_" + v.index.get

  /** Compute the DNF form of the given formula */
  private def convertToDnf(e: Expression): Expr = {
    val mathCmd = "BooleanConvert[" +  KeYmaeraToMathematica.fromKeYmaera(e) + ",DNF]"
    link.ml.evaluate(mathCmd)
    link.ml.waitForAnswer()
    link.ml.getExpr
  }

  /** Compile the DNF formula in Mathematica term to Spiral */
  private def compileMathDnfToSpiral(me: Expr, vars: List[Variable]) : String = {
    if(me.head().toString=="Or") {
      val dnfNum = me.length()
      var dnfPoly = new Array[String](dnfNum)
      for(i <- 0 until dnfNum)
        dnfPoly(i)=compileMathCnfToSpiral(me.args().apply(i), vars)
      "TForAny(\n  " + dnfNum +",\n  " + dnfPoly.mkString(",\n  ") + "\n)"
    } else compileMathCnfToSpiral(me,vars)
  }

  /** Compile the CNF formula in Mathematica term to Spiral */
  private def compileMathCnfToSpiral(me: Expr, vars: List[Variable]) : String = {
    if(me.head().toString=="And") {
      val cnfNum = me.length()
      var cnfPoly = new Array[String](cnfNum)
      for(i <- 0 until cnfNum)
        cnfPoly(i)=compileToSpiral(MathematicaToKeYmaera.fromMathematica(me.args().apply(i)), vars)
      "TForAll(" + cnfNum +", " + cnfPoly.mkString(", ") + ")"
    } else compileToSpiral(MathematicaToKeYmaera.fromMathematica(me), vars)
  }

  /** Compile the input formula to Spiral */
  private def compileToSpiral(e: Expression, vars: List[Variable]) = e match {
    case f : Formula => compileFormula(f, vars)
    case _ => throw new CodeGenerationException("The input expression: \n" + KeYmaeraXPrettyPrinter(e) + "\nis expected to be formula.")
  }

  /**
   * Compile a simple term, not in forms of polynomial
   *
   * @param t term
   * @return  compilation result
   */
  private def compileTerm(t: Term) : String = {
    require(t.sort == Real || t.sort == Unit, "can only deal with reals not with sort " + t.sort)
    t match {
      case Neg(c) => "neg(" + compileTerm(c) + ")"
      case Plus(l, r) => "add(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Minus(l, r) => "sub(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Times(l, r) => "mul(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Divide(l, r) => "div(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Power(l, r) => "pow(" + compileTerm(l) + ", " + compileTerm(r) + ")"

      // atomic terms
      case Number(n) =>
        assert(n.isValidDouble || n.isValidLong, throw new CodeGenerationException("Term " + KeYmaeraXPrettyPrinter(t) + " contains illegal numbers"))
        "TReal.value(" + n.underlying().toString + ")"
      case t: Variable => nameIdentifier(t)
      case FuncOf(fn, child) =>
        if(child.equals(Nothing)) nameIdentifier(fn)
        else nameIdentifier(fn) match {
          case "Abs" => "abs(" + compileTerm(child) + ")"
          case "DChebyshev" => "TDistance(TInfinityNorm(" + "2" + "))"  //hack for InfinityNorm of degree 2
          case _ => nameIdentifier(fn) + "(" + compileTerm(child) + ")"
        }
      // otherwise exception
      case _ => throw new CodeGenerationException("Conversion of term " + KeYmaeraXPrettyPrinter(t) + " is not defined")
    }
  }

  /**
   * Compile formula
   *
   * @param f     formula
   * @param vars  a list of variables
   * @return      compilation result
   */
  private def compileFormula(f: Formula, vars: List[Variable]) : String = {
    f match {
      // sub terms are formulas
      case Not(ff) => "logic_neg(" + compileFormula(ff, vars) + ")"
      case And(l, r) => "logic_and(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"
      case Or(l, r) => "logic_or(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"
      case Imply(l, r) => "logic_or(" + "logic_neg(" + compileFormula(l, vars) + ")" + ", " + compileFormula(r, vars) + ")"
      case Equiv(l, r) => "logic_equiv(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"

      // sub terms l and r are arithmetic terms,
      // if l and r are both polynomials, turn l ? r into l-r ? 0 for optimized result
      case Equal(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TEqual(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0))"
        else "TEqual(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + ")"
      case NotEqual(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TEqual(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0)))"
        else "TNot(TEqual(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + "))"
      case Greater(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TLess(" + compilePolynomialTerm(Minus(r, l), vars) + ", TReal.value(0))"
        else "TLess(" + compilePolynomialTerm(r, vars) + ", " + compilePolynomialTerm(l, vars) + ")"
      case GreaterEqual(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TLess(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0)))"
        else "TNot(TLess(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + "))"
      case Less(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TLess(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0))"
        else "TLess(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + ")"
      case LessEqual(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TLess(" + compilePolynomialTerm(Minus(r, l), vars) + ", TReal.value(0)))"
        else "TNot(TLess(" + compilePolynomialTerm(r, vars) + ", " + compilePolynomialTerm(l, vars) + "))"

      case True => "true"
      case False => "false"
      case Box(_, _) | Diamond(_, _) => throw new CodeGenerationException("Conversion of Box or Diamond modality is not allowed")
      case _ => throw new CodeGenerationException("Conversion of formula " + KeYmaeraXPrettyPrinter(f) + " is not defined")
    }
  }

  /**
   * Compile a polynomial term
   * if the polynomial term is encountered before, get the previously compiled result
   * otherwise compile the fresh polynomial term and updates the list of encounteredPolyTerm
   *
   * @param t     polynomial term
   * @param vars  a list of variables
   * @return      compiled polynomial term
   */
  private def compilePolynomialTerm(t: Term, vars: List[Variable]) : String = {
    if(encounteredPolyTerm.map(s => s._1).contains(t)) {
      encounteredPolyTerm.apply(encounteredPolyTerm.map(s => s._1).indexOf(t))._2
    } else {
      val generatedPoly = compileFreshPolynomialTerm(t, vars)
      encounteredPolyTerm = (t, generatedPoly) :: encounteredPolyTerm
      generatedPoly
    }
  }

  /**
   * Compile the polynomial term, this polynomial was not encountered before
   * 
   * @param t     term 
   * @param vars  a list of variables
   * @return      compiled polynomial term
   */
  private def compileFreshPolynomialTerm(t: Term, vars: List[Variable]) : String = {
    if(getSortedRelevantVars(t, vars).isEmpty) { 
      // t is not polynomial, compile t as a simple term
      compileTerm(t)
    } else {
      // get sorted variables in Mathematica syntax
      val mathVarsSorted = vars.map(v => KeYmaeraToMathematica.fromKeYmaera(v))
      val mathTerm = KeYmaeraToMathematica.fromKeYmaera(t)
      if(mathVarsSorted.length==1) {   
        // one relevant variable, t is single polynomial
        compileSinglePoly(mathTerm, mathVarsSorted)
      } else {    // more than one relevant variable, t is multi polynomial
        compileMultiPoly(mathTerm, mathVarsSorted)
      }
    }
  }

  /**
   * A simple check if a term is polynomial
   * 
   * @param t term
   * @return  true if the input term is not the predefined function of Abs or DChebyshev
   */
  private def isPolynomialTerm(t: Term) : Boolean = {
    t match {
      case FuncOf(fn, child) => !(nameIdentifier(fn) == "Abs" | nameIdentifier(fn) == "DChebyshev")
      case _ => true
    }
  }

  /**
   * Compiles polynomial with single main variable
   * 
   * @param mathTerm        input polynomial in Mathematica term
   * @param mathVarsSorted  input list of variables in Mathematica term
   * @return                compilation result in form of TEvalPolynomial(maxDegree, vectorName)
   */
  private def compileSinglePoly(mathTerm: Expr, mathVarsSorted: List[Expr]) : String = {
    val resCoeffList = computeCoeff(mathTerm, mathVarsSorted)
    val itemNumber = resCoeffList.length()
    var coeffArray: Array[Expression] = new Array[Expression](itemNumber)
    for(i <- 0 until itemNumber)
      coeffArray(i) = MathematicaToKeYmaera.fromMathematica(resCoeffList.args().apply(itemNumber - 1 - i))
    val vectorName = getNewVecName
    val ct: String = hcol.getConstTbl.concat(vectorName + " := var(\"" + vectorName + "\", TPtr(T_Real(64)));\n")
    hcol.setConstTbl(ct)
    compileSinglePolyCoeff(vectorName, coeffArray)
  }

  /**
   * Compile polynomial with many main variables
   *
   * @param mathTerm        input polynomial in Mathematica term
   * @param mathVarsSorted  input list of variables in Mathematica term
   * @return                compilation result in form of TEvalMultiPolynomial(maxDegree, variableNumber, vectorName)
   */
  private def compileMultiPoly(mathTerm: Expr, mathVarsSorted: List[Expr]) : String = {
    val resCoeffMap = computeCoeff(mathTerm, mathVarsSorted)
    val varNumber = mathVarsSorted.length
    val itemNumber = resCoeffMap.length
    var varArray = Array.ofDim[Int](itemNumber, varNumber)
    var coeffArray = new Array[Expression](itemNumber)
    var maxDegree = 0
    for(i <- 0 until itemNumber) {
      for(j <- 0 until varNumber) {
        varArray(i)(j) = resCoeffMap.args().apply(i).part(1).part(j+1).asInt()
        if(maxDegree < varArray(i)(j)) maxDegree = varArray(i)(j)
      }
      coeffArray(i) = MathematicaToKeYmaera.fromMathematica(resCoeffMap.args().apply(i).part(2))
    }
    val vectorName = getNewVecName
    val ct: String = hcol.getConstTbl.concat(vectorName + " := var(\"" + vectorName + "\", TPtr(T_Real(64)));\n")
    hcol.setConstTbl(ct)
    compileMultiPolyCoeff(vectorName, varArray, coeffArray, varNumber, maxDegree)
  }

  /**
   * Compute coefficients of a polynomial with Mathematica
   *
   * @param t     input polynomial in Mathematica term
   * @param vars  input list of variables in Mathematica term
   * @return      for single polynomial: a list of coefficients in ascending order of variable degree.
   *              for multi polynomial: a list of mappings between {var_1.degree, ... , var_n.degree} and coefficient
   */
  private def computeCoeff(t: Expr, vars: List[Expr]) : Expr = {
    var mathCmd = ""
    if(vars.length==1)
      mathCmd = "CoefficientList[" + t + "," + vars.head + "]"
    else {
      assert(vars.length > 1)
      mathCmd = "CoefficientRules[" + t + "," + "{" + vars.mkString(", ") + "}" + "]"
    }
    link.ml.evaluate(mathCmd)
    link.ml.waitForAnswer()
    link.ml.getExpr
  }

  /* Generates new vector name */
  private def getNewVecName : String = {
    val name = "d_"+vecNameCounter
    vecNameCounter+=1
    name
  }

  /**
   * Compile polynomial with single main variable
   *
   * @param vectorName  name of the coefficient vector
   * @param coeffArray  the array of coefficients
   * @return            compilation result in form of TEvalPolynomial(maxDegree, vectorName)
   *                    and instantiates the coefficient vectors in the header file
   */
  private def compileSinglePolyCoeff(vectorName: String, coeffArray: Array[Expression]) : String = {
    val maxDegree = coeffArray.length - 1
    val ceh = hcol.getCoefficients.concat("\n__int64 " + vectorName + "[] = {\n" + translateSinglePolyCoeffs(coeffArray) + "\n};\n")
    hcol.setCoefficients(ceh)
    "TEvalPolynomial(" + maxDegree + "," + vectorName + ")"
  }

  private def translateSinglePolyCoeffs(coeffArray: Array[Expression]) : String = "  " +
    coeffArray.map(
      ce => ce match {
        case Number(n) => translateToHex(n.underlying().doubleValue())
        case _ => KeYmaeraXPrettyPrinter(ce)
      }
    ).mkString(",\n  ")

  /**
   * Compile polynomial with many main variables
   *
   * @param vectorName  name of the coefficient vector
   * @param varArray    the array of variable degrees in array
   * @param coeffArray  the array of coefficients
   * @param varNumber   the number of variables
   * @param maxDegree   the maximum degree in the polynomial
   * @return            compilation result in form of TEvalMultiPolynomial(maxDegree, variableNumber, vectorName)
   *                    and instantiates the coefficient vectors in the header file
   */
  private def compileMultiPolyCoeff(vectorName: String, varArray: Array[Array[Int]], coeffArray: Array[Expression], varNumber: Int, maxDegree: Int) : String = {
    val ceh = hcol.getCoefficients.concat("\n__int64 " + vectorName + "[] = {\n" + translateMultiPolyCoeffs(varArray, coeffArray) + "\n};\n")
    hcol.setCoefficients(ceh)
    "TEvalMultiPolynomial(" + maxDegree + "," + varNumber + "," + vectorName + ")"
  }

  private def translateMultiPolyCoeffs(varArray: Array[Array[Int]], coeffArray: Array[Expression]) : String = {
    var coeffs = ""
    for(i <- coeffArray.indices) {
      val vars = varArray(i).mkString(",")
      coeffArray(i) match {
        case Number(n) => coeffs += "  (" + "{" + vars + "}, " + translateToHex(n.underlying().doubleValue()) + ")"
        case _ => coeffs += "  (" + "{" + vars + "}, " + KeYmaeraXPrettyPrinter(coeffArray(i)) + ")"
      }
      if(i != coeffArray.length-1) coeffs += ",\n"
    }
    coeffs
  }

  /** Translate a coefficient of Double type to Hex form */
  private def translateToHex(value: Double) = "0x" + java.lang.Long.toHexString(java.lang.Double.doubleToRawLongBits(value))
}




