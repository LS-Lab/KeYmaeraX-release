/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import com.wolfram.jlink.Expr
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.launcher.DefaultConfiguration
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXPrettyPrinter
import edu.cmu.cs.ls.keymaerax.tools.{KeYmaeraToMathematica, JLinkMathematicaLink, MathematicaToKeYmaera}

import scala.collection.immutable.Map

/**
 * Created by ran on 7/3/15.
 * @author Ran Ji
 */

/**
 * Hcol file consists of
 *  - monitor (.g): constant table + monitor
 *  - header (.h): coefficients vectors
 */
class Hcol {
  private var constTbl : String = ""
  private var monitor : String  = ""
  private var coeffs : String = ""

  def getConstTbl = this.constTbl
  def setConstTbl(ct : String) = this.constTbl = ct
  def getMonitor = this.monitor
  def setMonitor(mnt : String) = this.monitor = mnt
  def getCoefficients = this.coeffs
  def setCoefficients(ceh : String) = this.coeffs = ceh
}

class SpiralGenerator extends CodeGenerator {
  def apply(kExpr: Expression): String = apply(kExpr, Nil, "")._1
  def apply(kExpr: Expression, fileName: String) : String = apply(kExpr, Nil, fileName)._1
  def apply(kExpr: Expression, vars: List[Variable], fileName: String): (String, String) = generateSpiralMonitor(kExpr, vars, fileName)

  private val hcol = new Hcol

  /* Mathematica settings */
  private val mathematicaConfig: Map[String, String] = DefaultConfiguration.defaultMathematicaConfig
  private val link : JLinkMathematicaLink= new JLinkMathematicaLink()
  link.init(mathematicaConfig.apply(mathematicaConfig.keys.head), None)

  /* name counter used for generating new vector names */
  private var vecNameCounter : Int = 0

  /* printings for monitor generation */
  private def infoG(fileName: String) =
    "# *************************\n" +
      {if(fileName.nonEmpty) "* " + fileName + ".g\n" + "* \n" else "" } +
      "# Generated by KeYmaera X\n" +
      "# *************************\n"
  private val libs = "# imports\n" +
//    "Import(spl, formgen, code, rewrite, transforms, search, compiler, sigma, platforms, platforms.sse, paradigms.common, paradigms.vector, paradigms.cache, libgen, backend);\n" +
    "ImportAll(packages.hacms);\n" +
    "ImportAll(paradigms.vector);\n\n"
  private val monDec = "# monitor\n" +
    "t := \n"

  /* printings for coefficientHex generation */
  private def infoH(fileName: String) =
    "/**************************\n" +
      {if(fileName.nonEmpty) "* " + fileName + ".h\n" + "* \n" else "" } +
      "* Generated by KeYmaera X\n" +
      "**************************/\n\n"
  private def ifnDef(fileName: String) = "#ifndef _" + {if(fileName.nonEmpty) fileName.toUpperCase else "VECTOR"} + "_H_\n"
  private def define(fileName: String) = "#define _" + {if(fileName.nonEmpty) fileName.toUpperCase else "VECTOR"} + "_H_\n"
  private val endIf = "#endif"

  /**
   * Generate Spiral monitor
   *
   * @param kExpr KeYmaera X arithmetic expression got from modelPlex
   * @param vars  a list of variables
   * @param fileName  file name
   * @return .g code and .h code
   */
  def generateSpiralMonitor(kExpr: Expression, vars: List[Variable], fileName: String) : (String, String) = {
    
    // if the variable list is not empty, generate polynomial form, otherwise generate explicit form 
    val polynomialMode = vars.nonEmpty
    
    val sortedRlvtVars = getSortedRelevantVars(kExpr, vars)
    val spiralMonitor = compileToSpiral(kExpr, sortedRlvtVars)
    hcol.setMonitor(spiralMonitor)
    val gCode = infoG(fileName) + libs + {if(polynomialMode) "# declare constant table\n" + hcol.getConstTbl + "\n" else ""} + monDec + hcol.getMonitor + "\n;\n"
    val hCode =
      if(polynomialMode) infoH(fileName) + ifnDef(fileName) + define(fileName) + hcol.getCoefficients + endIf
      else ""
    (gCode, hCode)
  }

  private def compileToSpiral(e: Expression, vars: List[Variable]) = e match {
    case t : Term => compilePolynomialTerm(t, vars)
    case f : Formula => compileFormula(f, vars)
    case _ => ???
  }

  /**
   * Compile a simple term, not in forms of polynomial
   *
   * @param t term
   * @return  compilation result
   */
  private def compileTerm(t: Term) : String = {
    require(t.sort == Real || t.sort == Unit, "can only deal with reals not with sort " + t.sort)
    t match {
      case Neg(c) => "neg(" + compileTerm(c) + ")"
      case Plus(l, r) => "add(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Minus(l, r) => "sub(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Times(l, r) => "mul(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Divide(l, r) => "div(" + compileTerm(l) + ", " + compileTerm(r) + ")"
      case Power(l, r) => "pow(" + compileTerm(l) + ", " + compileTerm(r) + ")"

      // atomic terms
      case Number(n) =>
        assert(n.isValidDouble || n.isValidLong, throw new CodeGenerationException("Term " + KeYmaeraXPrettyPrinter(t) + " contains illegal numbers"))
        "TReal.value(" + n.underlying().toString + ")"
      case t: Variable =>
        if(t.index.isEmpty) t.name
        else t.name + "_" + t.index.get
      case FuncOf(fn, child) =>
        if(child.equals(Nothing)) fn.name
        else fn.name match {
          case "Abs" => "abs(" + compileTerm(child) + ")"
          case "DChebyshev" => "TDistance(TInfinityNorm(" + "2" + "))"  //hack for InfinityNorm of degree 2
          case _ => fn.name + "(" + compileTerm(child) + ")"
        }
      // otherwise exception
      case _ => throw new CodeGenerationException("Conversion of term " + KeYmaeraXPrettyPrinter(t) + " is not defined")
    }
  }

  /**
   * Compile formula
   *
   * @param f     formula
   * @param vars  a list of variables
   * @return      compilation result
   */
  private def compileFormula(f: Formula, vars: List[Variable]) : String = {
    f match {
      // sub terms are formulas
      case Not(ff) => "logic_neg(" + compileFormula(ff, vars) + ")"
      case And(l, r) => "logic_and(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"
      case Or(l, r) => "logic_or(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"
      case Imply(l, r) => "logic_or(" + "logic_neg(" + compileFormula(l, vars) + ")" + ", " + compileFormula(r, vars) + ")"
      case Equiv(l, r) => "logic_equiv(" + compileFormula(l, vars) + ", " + compileFormula(r, vars) + ")"

      // sub terms l and r are arithmetic terms, 
      // if l and r are both polynomials, turn l ? r into l-r ? 0 for optimized result 
      case Equal(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TEqual(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0))"
        else "TEqual(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + ")"
      case NotEqual(l, r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TEqual(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0)))"
        else "TNot(TEqual(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + "))"
      case Greater(l,r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TLess(" + compilePolynomialTerm(Minus(r, l), vars) + ", TReal.value(0))"
        else "TLess(" + compilePolynomialTerm(r, vars) + ", " + compilePolynomialTerm(l, vars) + ")"
      case GreaterEqual(l,r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TLess(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0)))"
        else "TNot(TLess(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + "))"
      case Less(l,r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TLess(" + compilePolynomialTerm(Minus(l, r), vars) + ", TReal.value(0))"
        else "TLess(" + compilePolynomialTerm(l, vars) + ", " + compilePolynomialTerm(r, vars) + ")"
      case LessEqual(l,r) =>
        if(isPolynomialTerm(l) & isPolynomialTerm(r)) "TNot(TLess(" + compilePolynomialTerm(Minus(r, l), vars) + ", TReal.value(0)))"
        else "TNot(TLess(" + compilePolynomialTerm(r, vars) + ", " + compilePolynomialTerm(l, vars) + "))"

      case True => "true"
      case False => "false"
      case Box(_, _) | Diamond(_, _) => throw new CodeGenerationException("Conversion of Box or Diamond modality is not allowed")
      case _ => throw new CodeGenerationException("Conversion of formula " + KeYmaeraXPrettyPrinter(f) + " is not defined")
    }
  }

  /**
   * Compile the polynomial term
   * 
   * @param t     term 
   * @param vars  a list of variables
   * @return      compiled polynomial term
   */
  private def compilePolynomialTerm(t: Term, vars: List[Variable]) : String = {
    if(getSortedRelevantVars(t, vars).isEmpty) { 
      // t is not polynomial, compile t as a simple term
      compileTerm(t)
    } else {
      // get sorted variables in Mathematica syntax
      val mathVarsSorted = vars.map(v => KeYmaeraToMathematica.fromKeYmaera(v))
      val mathTerm = KeYmaeraToMathematica.fromKeYmaera(t)
      if(mathVarsSorted.length==1) {   
        // one relevant variable, t is single polynomial
        compileSinglePoly(mathTerm, mathVarsSorted)
      } else {    // more than one relevant variable, t is multi polynomial
        compileMultiPoly(mathTerm, mathVarsSorted)
      }
    }
  }

  /**
   * Get a list of alphabetically sorted variables relevant to (occur in) the given expression
   * 
   * @param e     expression
   * @param vars  list of variables
   * @return      a list of sorted variables relevant to e
   */
  private def getSortedRelevantVars(e: Expression, vars: List[Variable]) : List[Variable] = {
    val allSortedNames = StaticSemantics.symbols(e).toList.sorted
    var sortedRelevantVars = List[Variable]()
    for(i <- vars.indices) {
      if(allSortedNames.contains(vars.apply(i)))
        sortedRelevantVars = vars.apply(i) :: sortedRelevantVars
    }
    sortedRelevantVars.sortWith(_.toString < _.toString)
  }

  /**
   * A simple check if a term is polynomial
   * 
   * @param t term
   * @return  true if the input term is not the predefined function of Abs or DChebyshev
   */
  private def isPolynomialTerm(t: Term) : Boolean = {
    t match {
      case FuncOf(fn, child) => !(fn.name == "Abs" | fn.name == "DChebyshev")
      case _ => true
    }
  }

  /**
   * Compiles polynomial with single main variable
   * 
   * @param mathTerm        input polynomial in Mathematica term
   * @param mathVarsSorted  input list of variables in Mathematica term
   * @return                compilation result in form of TEvalPolynomial(maxDegree, vectorName)
   */
  private def compileSinglePoly(mathTerm: Expr, mathVarsSorted: List[Expr]) : String = {
    val resCoeffList = computeCoeff(mathTerm, mathVarsSorted)
    val itemNumber = resCoeffList.length()
    var coeffArray: Array[Expression] = new Array[Expression](itemNumber)
    for(i <- 0 until itemNumber)
      coeffArray(i) = MathematicaToKeYmaera.fromMathematica(resCoeffList.args().apply(itemNumber - 1 - i))
    val vectorName = getNewVecName
    val ct: String = hcol.getConstTbl.concat(vectorName + " := var(\"" + vectorName + "\", TPtr(T_Real(64)));\n")
    hcol.setConstTbl(ct)
    compileSinglePolyCoeff(vectorName, coeffArray)
  }

  /**
   * Compile polynomial with many main variables
   *
   * @param mathTerm        input polynomial in Mathematica term
   * @param mathVarsSorted  input list of variables in Mathematica term
   * @return                compilation result in form of TEvalMultiPolynomial(maxDegree, variableNumber, vectorName)
   */
  private def compileMultiPoly(mathTerm: Expr, mathVarsSorted: List[Expr]) : String = {
    val resCoeffMap = computeCoeff(mathTerm, mathVarsSorted)
    val varNumber = mathVarsSorted.length
    val itemNumber = resCoeffMap.length
    var varArray = Array.ofDim[Int](itemNumber, varNumber)
    var coeffArray = new Array[Expression](itemNumber)
    var maxDegree = 0
    for(i <- 0 until itemNumber) {
      for(j <- 0 until varNumber) {
        varArray(i)(j) = resCoeffMap.args().apply(i).part(1).part(j+1).asInt()
        if(maxDegree < varArray(i)(j)) maxDegree = varArray(i)(j)
      }
      coeffArray(i) = MathematicaToKeYmaera.fromMathematica(resCoeffMap.args().apply(i).part(2))
    }
    val vectorName = getNewVecName
    val ct: String = hcol.getConstTbl.concat(vectorName + " := var(\"" + vectorName + "\", TPtr(T_Real(64)));\n")
    hcol.setConstTbl(ct)
    compileMultiPolyCoeff(vectorName, varArray, coeffArray, varNumber, maxDegree)
  }

  /**
   * Compute coefficients of a polynomial with Mathematica
   *
   * @param t     input polynomial in Mathematica term
   * @param vars  input list of variables in Mathematica term
   * @return      for single polynomial: a list of coefficients in ascending order of variable degree.
   *              for multi polynomial: a list of mappings between {var_1.degree, ... , var_n.degree} and coefficient
   */
  private def computeCoeff(t: Expr, vars: List[Expr]) : Expr = {
    var mathCmd = ""
    if(vars.length==1)
      mathCmd = "CoefficientList[" + t + "," + vars.head + "]"
    else {
      assert(vars.length > 1)
      mathCmd = "CoefficientRules[" + t + "," + "{" + vars.mkString(", ") + "}" + "]"
    }
    link.ml.evaluate(mathCmd)
    link.ml.waitForAnswer()
    link.ml.getExpr
  }

  /* Generates new vector name */
  private def getNewVecName : String = {
    val name = "d_"+vecNameCounter
    vecNameCounter+=1
    name
  }

  /**
   * Compile polynomial with single main variable
   *
   * @param vectorName  name of the coefficient vector
   * @param coeffArray  the array of coefficients
   * @return            compilation result in form of TEvalPolynomial(maxDegree, vectorName)
   *                    and instantiates the coefficient vectors in the header file
   */
  private def compileSinglePolyCoeff(vectorName: String, coeffArray: Array[Expression]) : String = {
    val maxDegree = coeffArray.length - 1
    val ceh = hcol.getCoefficients.concat("\n__int64 " + vectorName + "[] = {\n" + translateSinglePolyCoeffs(coeffArray) + "\n};\n")
    hcol.setCoefficients(ceh)
    "TEvalPolynomial(" + maxDegree + "," + vectorName + ")"
  }

  private def translateSinglePolyCoeffs(coeffArray: Array[Expression]) : String = {
    var coeffs = ""
    for(i <- coeffArray.indices) {
      coeffArray(i) match {
        case Number(n) => coeffs += "  " + translateToHex(n.underlying().doubleValue())
        case _ => coeffs += "  " + KeYmaeraXPrettyPrinter(coeffArray(i))
      }
      if(i != coeffArray.length-1) coeffs += ",\n"
    }
    coeffs
  }

  /**
   * Compile polynomial with many main variables
   *
   * @param vectorName  name of the coefficient vector
   * @param varArray    the array of variable degrees in array
   * @param coeffArray  the array of coefficients
   * @param varNumber   the number of variables
   * @param maxDegree   the maximum degree in the polynomial
   * @return            compilation result in form of TEvalMultiPolynomial(maxDegree, variableNumber, vectorName)
   *                    and instantiates the coefficient vectors in the header file
   */
  private def compileMultiPolyCoeff(vectorName: String, varArray: Array[Array[Int]], coeffArray: Array[Expression], varNumber: Int, maxDegree: Int) : String = {
    val ceh = hcol.getCoefficients.concat("\n__int64 " + vectorName + "[] = {\n" + translateMultiPolyCoeffs(varArray, coeffArray) + "\n};\n")
    hcol.setCoefficients(ceh)
    "TEvalMultiPolynomial(" + maxDegree + "," + varNumber + "," + vectorName + ")"
  }

  private def translateMultiPolyCoeffs(varArray: Array[Array[Int]], coeffArray: Array[Expression]) : String = {
    var coeffs = ""
    for(i <- coeffArray.indices) {
      val vars = varArray(i).mkString(",")
      coeffArray(i) match {
        case Number(n) => coeffs += "  (" + "{" + vars + "}, " + translateToHex(n.underlying().doubleValue()) + ")"
        case _ => coeffs += "  (" + "{" + vars + "}, " + KeYmaeraXPrettyPrinter(coeffArray(i)) + ")"
      }
      if(i != coeffArray.length-1) coeffs += ",\n"
    }
    coeffs
  }

  /* Translate a coefficient of Double type to Hex form */
  private def translateToHex(value: Double) = "0x" + java.lang.Long.toHexString(java.lang.Double.doubleToRawLongBits(value))
}




