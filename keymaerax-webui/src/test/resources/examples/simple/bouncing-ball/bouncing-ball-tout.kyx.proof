Lemma "bouncing-ball-tout.key".
Sequent.

==>
Formula: ((((v)^((2))) <= ((((2))*(g()))*((H)-(h))))&(((h) >= ((0)))&(((g()) > ((0)))&(((H) >= ((0)))&((((0)) <= (c))&((c) < ((1))))))))->([{{{h'=v,v'=-(g())&(h) >= ((0))}};{{?((h) >= ((0)));}++{{?((h) = ((0)));};{v:=-((c)*(v));}}}}*](((h) >= ((0)))&((h) <= (H))))

End.
Tool.
  tool """"KeYmaera X""""
  model """"Functions.
  R g().
End.

ProgramVariables.
  R h.
  R v.
  R t.
  R c.
  R V.
  R H.
End.


Problem.
    v^2<=2*g()*(H-h) & h>=0 & g()>0 & H>=0 & 0<=c & c<1
 -> [
      {
        {h'=v, v'=-g() & h>=0}
        {  ?h>=0;
        ++ ?h=0; v := -c*v; }
      }* /*@invariant(v^2<=2*g()*(H-h) & h>=0)*/
    ]
    (h>=0 & h<=H)
End.""""
  tactic """"import org.keymaerax.bellerophon.BelleExpr

import org.keymaerax.btactics.TactixLibrary._
import org.keymaerax.parser.StringConverter._

import scala.language.postfixOps

class BouncingBallTacticGenerator extends (() => BelleExpr) {

  def apply() = {
    implyR(1) & (andL('L)*) & loop("v^2<=2*g()*(H-h) & h>=0".asFormula)(1) <(
      QE,
      QE,
      composeb(1) & choiceb(1, 1::Nil) & testb(1, 1::0::Nil) & composeb(1, 1::1::Nil) &
        testb(1, 1::1::Nil) & assignb(1, 1::1::1::Nil) & diffSolve(1) & allR(1) & (implyR(1)*2) &
        allL("t_".asTerm)('Llast) & QE
      )
  }

}
""""
  proof """"""""
End.
