/*
 * Copyright (c) Carnegie Mellon University, Karlsruhe Institute of Technology.
 * See LICENSE.txt for the conditions of this license.
 */

package org.keymaerax.btactics

import org.keymaerax.Configuration
import org.keymaerax.btactics.TactixLibrary.QE
import org.keymaerax.core.True
import org.keymaerax.parser.StringConverter._
import org.keymaerax.tags.AdvocatusTest
import org.keymaerax.tools.ext.JLinkMathematicaLink
import org.keymaerax.tools.qe.MathematicaToKeYmaera
import org.scalatest.PrivateMethodTester

/**
 * Tests with known exploits.
 *
 * @author
 *   Stefan Mitsch
 */
@AdvocatusTest
class KnownQEExploitTests extends TacticTestBase with PrivateMethodTester {

  "Mathematica" should "EXPLOIT: not simplify nested max and abs unsoundly" in withMathematica { _ =>
    // proves with Reduce but not with Resolve
    // test separation with 'm' to prevent reading results from the cache
    def s(m: String) = s"""
                          #A>0, B>0, C>0, D>0,
                          #abs(m0)>D,
                          #dx^2+dy^2=1, (dy*r)^2+(dx*r)^2=r^2,
                          #max(abs(m0),abs(n0))>D+A^2/B
                          #==>
                          #abs($m)>B | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) {
      proveBy(s("mC"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Resolve from answering incorrectly"
    }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) {
      proveBy(s("mD"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Reduce from answering incorrectly"
    }

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) { proveBy(s("mA"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Resolve answered incorrectly" }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) { proveBy(s("mB"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Reduce answered incorrectly" }
  }

  it should "EXPLOIT: not simplify nested max and abs unsoundly 2" in withMathematica { _ =>
    // proves with both Reduce and Resolve
    // test separation with 'm' to prevent reading results from the cache
    def s(m: String) = s"""
                          #A>0, B>0, D>0,
                          #abs(m0)>D,
                          #dx^2+dy^2=1,
                          #(dy*r)^2+(dx*r)^2=r^2,
                          #max(abs(m0),abs(n0))>D+A^2/B
                          #==>
                          #abs($m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) {
      proveBy(s("mC"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Resolve from answering incorrectly"
    }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) {
      proveBy(s("mD"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Reduce from answering incorrectly"
    }

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) { proveBy(s("mA"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Resolve answered incorrectly" }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) { proveBy(s("mB"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Reduce answered incorrectly" }
  }

  it should "EXPLOIT: not simplify nested max and abs unsoundly 3" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    // test separation with 'm' to prevent reading results from the cache
    def s(m: String) = s"""
                          #B>0, D>0,
                          #abs(m0)>D,
                          #dx^2+dy^2=1,
                          #(dy*r)^2+(dx*r)^2=r^2,
                          #max(abs(m0),abs(n0))>D+A^2/B
                          #==>
                          #abs($m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) {
      proveBy(s("mC"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Resolve from answering incorrectly"
    }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) {
      proveBy(s("mD"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Reduce from answering incorrectly"
    }

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) { proveBy(s("mA"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Resolve answered incorrectly" }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) { proveBy(s("mB"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Reduce answered incorrectly" }
  }

  it should "EXPLOT: not simplify nested max and abs unsoundly 4" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    // test separation with 'm' to prevent reading results from the cache
    def s(m: String) = s"""
                          #B>0,
                          #abs(m0)>D,
                          #dx^2+dy^2=1,
                          #(dy*r)^2+(dx*r)^2=r^2,
                          #max(abs(m0),abs(n0))>D+A^2/B
                          #==>
                          #abs($m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) {
      proveBy(s("mC"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Resolve from answering incorrectly"
    }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) {
      proveBy(s("mD"), QE) should not be Symbol("proved") withClue
        "EXPLOIT: abs/min/max not expanded to prevent Reduce from answering incorrectly"
    }

    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")
    ) { proveBy(s("mA"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Resolve answered incorrectly" }
    withTemporaryConfig(
      Map(Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true", Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")
    ) { proveBy(s("mB"), QE) should not be Symbol("proved") withClue "EXPLOIT: verbatim Reduce answered incorrectly" }
  }

  it should "EXPLOIT: insist on terms being reals for unnatural powers" in withMathematica { _ =>
    proveBy("x>=0 ==> (x^(1/2))^2 = x".asSequent, QE) shouldBe Symbol("proved")
    proveBy("x>=0, (x^(1/2))^2 = y ==> y=x".asSequent, QE) shouldBe Symbol("proved")
    proveBy("==> (x^(1/2))^2 = x".asSequent, QE) should not be Symbol("proved") withClue
      "EXPLOIT: unnatural powers not prevented in QE auto-translation"
    proveBy("(x^(1/2))^2 = y ==> y=x".asSequent, QE) should not be Symbol("proved") withClue
      "EXPLOIT: unnatural powers not prevented in QE auto-translation"

  }

  it should "EXPLOIT: prove addition of non-negative exponents only" in withMathematica { _ =>
    proveBy("i>=0, j>=0 ==> x^(i+j) = x^i*x^j".asSequent, QE) shouldBe Symbol("proved")
    proveBy("           ==> x^(i+j) = x^i*x^j".asSequent, QE) should not be Symbol("proved") withClue
      "EXPLOIT: hidden negative exponent not prevented in QE auto-translation"
  }

  it should "EXPLOIT: not use chain fractions" in withMathematica { tool =>
    // proved by Mathematica when 0.1/1 is converted to Rational[Rational[1,10],1]
    proveBy("==> 0.1/1=0.1 -> false".asSequent, QE) should not be Symbol("proved") withClue
      "EXPLOIT: chain fraction not prevented in QE auto-translation"
    val getLink = PrivateMethod[JLinkMathematicaLink](Symbol("link"))
    val link = tool.invokePrivate(getLink())
    link
      .runUnchecked(
        "Reduce[Implies[Equal[Rational[Rational[1, 10], 1], Rational[1, 10]], False], {}, Reals]",
        MathematicaToKeYmaera,
      )
      ._2 should not be True withClue "EXPLOIT: verbatim Reduce chain fraction answered incorrectly"
  }

  it should "EXPLOIT: not assume that square roots are always non-negative (1)" in withMathematica { _ =>
    proveBy("\\forall x (x^2)^(1/2) >= 0".asFormula, QE) should not be Symbol("proved")
  }

  it should "EXPLOIT: not assume that square roots are always non-negative (2)" in withMathematica { _ =>
    proveBy("\\forall x (x <= 0 -> (x^2)^(1/2) = -x)".asFormula, QE) should not be Symbol("proved")
  }

  it should "EXPLOIT: not assume that square roots are always non-negative (3)" in withMathematica { _ =>
    proveBy("\\forall x ((x^2)^(1/2))^(1/2) >= 0".asFormula, QE) should not be Symbol("proved")
  }

}
