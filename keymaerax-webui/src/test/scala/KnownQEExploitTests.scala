/**
* Copyright (c) Carnegie Mellon University.
* See LICENSE.txt for the conditions of this license.
*/

import edu.cmu.cs.ls.keymaerax.Configuration
import edu.cmu.cs.ls.keymaerax.btactics.TactixLibrary.QE
import edu.cmu.cs.ls.keymaerax.btactics.TacticTestBase
import edu.cmu.cs.ls.keymaerax.core.True
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import edu.cmu.cs.ls.keymaerax.tags.AdvocatusTest
import edu.cmu.cs.ls.keymaerax.tools.{JLinkMathematicaLink, MathematicaToKeYmaera}
import org.scalatest.PrivateMethodTester

/**
  * Tests with known exploits.
  *
  * @author Stefan Mitsch
  */
@AdvocatusTest
class KnownQEExploitTests extends TacticTestBase with PrivateMethodTester {

  "Mathematica" should "not simplify nested max and abs unsoundly" in withMathematica { _ =>
    // proves with Reduce but not with Resolve
    val s = """
      #A>0, B>0, C>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1, (dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>B | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should not be 'proved // correct
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should /*not*/ be('proved) // exploit
    }

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should not be 'proved
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    }
  }

  it should "not simplify nested max and abs unsoundly 2" in withMathematica { _ =>
    // proves with both Reduce and Resolve
    val s = """
      #A>0, B>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should /*not*/ be('proved)
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should /*not*/ be('proved) // exploit
    }

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    }
  }

  it should "not simplify nested max and abs unsoundly 3" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    val s = """
      #B>0, D>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should /*not*/ be('proved) // exploit
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved // correct
    }

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved
    }
  }

  it should "not simplify nested max and abs unsoundly 4" in withMathematica { _ =>
    // proves with Resolve but not with Reduce
    val s = """
      #B>0,
      #abs(m0)>D,
      #dx^2+dy^2=1,
      #(dy*r)^2+(dx*r)^2=r^2,
      #max(abs(m0),abs(n0))>D+A^2/B
      #==>
      #abs(m)>D | abs(n)>E
    """.stripMargin('#').asSequent

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should /*not*/ be('proved) // exploit
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "true",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved // correct
    }

    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Resolve")) {
      proveBy(s, QE) should not be 'proved // fix with expanding all interpreted function symbols
    }
    withTemporaryConfig(Map(
        Configuration.Keys.QE_ALLOW_INTERPRETED_FNS -> "false",
        Configuration.Keys.MATHEMATICA_QE_METHOD -> "Reduce")) {
      proveBy(s, QE) should not be 'proved
    }
  }

  it should "insist on terms being reals for unnatural powers" in withMathematica { _ =>
    proveBy("==> (x^(1/2))^2 = x".asSequent, QE) should /*not*/ be ('proved) // exploit
    proveBy("x>=0 ==> (x^(1/2))^2 = x".asSequent, QE) shouldBe 'proved
    proveBy("(x^(1/2))^2 = y ==> y=x".asSequent, QE) should /*not*/ be ('proved) // exploit
    proveBy("x>=0, (x^(1/2))^2 = y ==> y=x".asSequent, QE) shouldBe 'proved
  }

  it should "not use chain fractions" in withMathematica { tool =>
    // proved by Mathematica when 0.1/1 is converted to Rational[Rational[1,10],1]
    proveBy("==> 0.1/1=0.1 -> false".asSequent, QE) should not be 'proved
    val getLink = PrivateMethod[JLinkMathematicaLink]('link)
    val link = tool.invokePrivate(getLink())
    link.runUnchecked(
      "Reduce[Implies[Equal[Rational[Rational[1, 10], 1], Rational[1, 10]], False], {}, Reals]",
      MathematicaToKeYmaera)._2 should /*not*/ be (True) // exploit
  }

}
