/**
  * Copyright (c) Carnegie Mellon University.
  * See LICENSE.txt for the conditions of this license.
  */

package edu.cmu.cs.ls.keymaerax.codegen

import java.io.File

import edu.cmu.cs.ls.keymaerax.btactics.{ModelPlex, TacticTestBase}
import edu.cmu.cs.ls.keymaerax.core.{NamedSymbol, Variable}
import edu.cmu.cs.ls.keymaerax.parser.KeYmaeraXParser
import edu.cmu.cs.ls.keymaerax.launcher.KeYmaeraX
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._
import testHelper.KeYmaeraXTestTags.IgnoreInBuildTest

/**
 * Tests the C++ ModelPlex code generator.
 * @author Ran Ji
 * @author Stefan Mitsch
 */
class CCodeGeneratorTests extends TacticTestBase {

  // terms

  /** Wraps the monitor expression in the monitor boilerplate code. */
  private def expectedMonitor(compiledMonitorExpr: String,
                              paramDecl: String = "", stateDecl: String = "", inputDecl: String = "",
                              kind: String="boolean"): String = {
    val (safetyDistBody, monitorSatisfiedBody) = kind match {
      case "boolean" => (compiledMonitorExpr + " ? 0.0 : 1.0", "boundaryDist(pre,curr,params) <= 0.0")
      case "metric" => (
        compiledMonitorExpr.substring(0, compiledMonitorExpr.indexOf("<")),
        "boundaryDist(pre,curr,params)" + compiledMonitorExpr.substring(compiledMonitorExpr.indexOf("<")))
    }

    def structBody(body: String) = if (body.isEmpty) "" else "{\n  " + body + "\n} "

    s"""/**************************
       | *
       | * Generated by KeYmaera X
       | **************************/
       |
       |#include <math.h>
       |#include <stdbool.h>
       |
       |typedef struct parameters ${structBody(paramDecl)}parameters;
       |
       |typedef struct state ${structBody(stateDecl)}state;
       |
       |typedef struct input ${structBody(inputDecl)}input;
       |
       |/* Computes distance to safety boundary on prior and current state (negative == safe, positive == unsafe) */
       |long double boundaryDist(state pre, state curr, const parameters* const params) {
       |  return $safetyDistBody;
       |}
       |
       |/* Evaluates monitor condition in prior and current state */
       |bool monitorSatisfied(state pre, state curr, const parameters* const params) {
       |  return $monitorSatisfiedBody;
       |}
       |
       |/* Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor */
       |state monitoredCtrl(state curr, const parameters* const params, const input* const in,
       |                    state (*ctrl)(state,const parameters* const,const input* const), state (*fallback)(state,const parameters* const,const input* const)) {
       |  state pre = curr;
       |  state post = (*ctrl)(pre,params,in);
       |  if (!monitorSatisfied(pre,post,params)) return (*fallback)(pre,params,in);
       |  else return post;
       |}
       |
       |""".stripMargin
  }

  "numbers" should "compile floating point" in {
    (new CGenerator(new CMonitorGenerator()))("2+1.5>3.25".asFormula) shouldBe expectedMonitor("(((2)) + ((1.5)))>((3.25))")
  }

  it should "compile large number" in {
    (new CGenerator(new CMonitorGenerator()))("9223372036854775807>1".asFormula) shouldBe expectedMonitor("((9223372036854775807))>((1))")
  }

  it should "throw exception for too large number" in {
    a [CodeGenerationException] should be thrownBy (new CGenerator(new CMonitorGenerator()))("92233720368547758079>1".asFormula)
  }

  "variables" should "compile with index" in {
    val paramDecls =
      """long double y_1;
        |  long double z;""".stripMargin
    val stateDecls = "long double x;"
    (new CGenerator(new CMonitorGenerator()))("x*z-y_1>1".asFormula, Set(Variable("x"))) shouldBe
      expectedMonitor("(((pre.x)*(params->z)) - (params->y_1))>((1))", paramDecls, stateDecls)
  }

  "nullary functions" should "compile to parameters" in {
    (new CGenerator(new CMonitorGenerator()))("x()>1".asFormula) shouldBe expectedMonitor("(params->x)>((1))", "long double x;")
  }

  "power" should "compile int exp" in {
    (new CGenerator(new CMonitorGenerator()))("x^3>1".asFormula) shouldBe
      expectedMonitor("(((params->x)*(params->x)*(params->x)))>((1))", "long double x;")
  }

  it should "compile neg int exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))("(x+y)^-3>1".asFormula) shouldBe expectedMonitor(
      "((1.0/(((params->x) + (params->y))*((params->x) + (params->y))*((params->x) + (params->y)))))>((1))", paramDecls)
  }

  it should "compile any exp" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))("x^y>1".asFormula) shouldBe
      expectedMonitor("((pow((params->x),(params->y))))>((1))", paramDecls)
  }

  "abs" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))("abs(x-y)>0".asFormula) shouldBe
      expectedMonitor("(fabsl((params->x) - (params->y)))>((0))", paramDecls)
  }

  "min" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))("min(x,y)<=x".asFormula) shouldBe
      expectedMonitor("(fminl(params->x, params->y))<=(params->x)", paramDecls)
  }

  "max" should "compile" in {
    val paramDecls =
      """long double x;
        |  long double y;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))("max(x,y)>=x".asFormula) shouldBe
      expectedMonitor("(fmaxl(params->x, params->y))>=(params->x)", paramDecls)
  }

  "C generator" should "compile function with 2 parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y)>g(y,z)".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double);\nlong double g(long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y()))>(g(y(), z()));\n}\n\n")
  }

  it should "compile function with more parameters" ignore {
    (new CGenerator(new CMonitorGenerator()))("f(x,y,z)>0".asFormula) should be("/**************************\n * Generated by KeYmaera X\n **************************/\n\n" +
      "#include <math.h>\n#include <stdbool.h>\n\n" +
      "/* function declaration */\nlong double f(long double, long double, long double);\nlong double x();\nlong double y();\nlong double z();\n\n" +
      "/* monitor */\nbool monitor () {\n  return (f(x(), y(), z()))>((0));\n}\n\n")
  }


  // hacms case studies

  "robix" should "generate C code for passivesafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double w;
        |  long double xo;
        |  long double yo;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("w"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t"))) shouldBe expectedMonitor(
      "(((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params->V)*(params->V))))&&((((curr.a)==(-(params->B)))&&(((curr.w)==(pre.w))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0))))))))))||((((params->v)==((0)))&&(((curr.a)==((0)))&&(((curr.w)==((0)))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))||(((-(params->B))<=(curr.a))&&(((curr.a)<=(params->A))&&(((curr.r)!=((0)))&&((((curr.w)*(curr.r))==(params->v))&&(((((!(((params->x) - (curr.xo))>=((0))))||(((params->x) - (curr.xo))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->V)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V))))))))&&((!(((params->x) - (curr.xo))<=((0))))||(((curr.xo) - (params->x))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->V)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V)))))))))||(((!(((params->y) - (curr.yo))>=((0))))||(((params->y) - (curr.yo))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->V)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V))))))))&&((!(((params->y) - (curr.yo))<=((0))))||(((curr.yo) - (params->y))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->V)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V))))))))))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.r)==(curr.r))&&(((curr.xo)==(curr.xo))&&(((curr.yo)==(curr.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))))))))",
      paramDecls, stateDecls)
    }

  it should "generate C code for passivesafety_renamed" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafety_renamed.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double Vo;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dxo;
        |  long double dyo;
        |  long double om;
        |  long double r;
        |  long double t;
        |  long double xo;
        |  long double yo;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("a"),Variable("om"),Variable("r"),Variable("xo"),Variable("yo"),
      Variable("dxo"),Variable("dyo"),Variable("t"))) shouldBe
      expectedMonitor(
        "(((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params->Vo)*(params->Vo))))&&((((curr.a)==(-(params->B)))&&(((curr.om)==(pre.om))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0))))))))))||((((params->v)==((0)))&&(((curr.a)==((0)))&&(((curr.om)==((0)))&&(((curr.r)==(pre.r))&&(((curr.xo)==(pre.xo))&&(((curr.yo)==(pre.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))||(((-(params->B))<=(curr.a))&&(((curr.a)<=(params->A))&&(((curr.r)!=((0)))&&((((curr.om)*(curr.r))==(params->v))&&(((((!(((params->x) - (curr.xo))>=((0))))||(((params->x) - (curr.xo))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->Vo)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->Vo))))))))&&((!(((params->x) - (curr.xo))<=((0))))||(((curr.xo) - (params->x))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->Vo)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->Vo)))))))))||(((!(((params->y) - (curr.yo))>=((0))))||(((params->y) - (curr.yo))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->Vo)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->Vo))))))))&&((!(((params->y) - (curr.yo))<=((0))))||(((curr.yo) - (params->y))>((((((params->v)*(params->v)))/(((2))*(params->B))) + (((params->Vo)*(params->v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->Vo))))))))))&&(((curr.a)==(curr.a))&&(((curr.om)==(curr.om))&&(((curr.r)==(curr.r))&&(((curr.xo)==(curr.xo))&&(((curr.yo)==(curr.yo))&&(((curr.dxo)==(curr.dxo))&&(((curr.dyo)==(curr.dyo))&&((curr.t)==((0)))))))))))))))))",
        paramDecls, stateDecls)
  }

  it should "generate C code for passivesafetyabs" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))(monitorExp, vars) shouldBe
      expectedMonitor(
        "(((((curr.dxo)*(curr.dxo))) + (((curr.dyo)*(curr.dyo))))<=(((params->V)*(params->V))))&&((((((0))<=(params->ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(pre.xo))&&((curr.yo)==(pre.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==(pre.w)))&&((curr.a)==(-(params->B))))&&((curr.r)==(pre.r)))&&((curr.t)==((0)))))||((((pre.v)==((0)))&&(((((0))<=(params->ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(pre.xo))&&((curr.yo)==(pre.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==((0))))&&((curr.a)==((0))))&&((curr.r)==(pre.r)))&&((curr.t)==((0))))))||((((-(params->B))<=(curr.a))&&((curr.a)<=(params->A)))&&(((curr.r)!=((0)))&&((((curr.w)*(curr.r))==(pre.v))&&((((fabsl((pre.x) - (curr.xo)))>((((((pre.v)*(pre.v)))/(((2))*(params->B))) + (((params->V)*(pre.v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((pre.v) + (params->V)))))))||((fabsl((pre.y) - (curr.yo)))>((((((pre.v)*(pre.v)))/(((2))*(params->B))) + (((params->V)*(pre.v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((pre.v) + (params->V))))))))&&(((((0))<=(params->ep))&&((pre.v)>=((0))))&&((((((((((((((curr.xo)==(curr.xo))&&((curr.yo)==(curr.yo)))&&((curr.dxo)==(curr.dxo)))&&((curr.dyo)==(curr.dyo)))&&((curr.x)==(pre.x)))&&((curr.y)==(pre.y)))&&((curr.dx)==(pre.dx)))&&((curr.dy)==(pre.dy)))&&((curr.v)==(pre.v)))&&((curr.w)==(curr.w)))&&((curr.a)==(curr.a)))&&((curr.r)==(curr.r)))&&((curr.t)==((0)))))))))))",
        paramDecls, stateDecls)
  }

  it should "generate metric C code for passivesafetyabs" in withMathematica { _ =>
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val paramDecls =
      """long double A;
        |  long double B;
        |  long double V;
        |  long double ep;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dxo;
        |  long double dy;
        |  long double dyo;
        |  long double r;
        |  long double t;
        |  long double v;
        |  long double w;
        |  long double x;
        |  long double xo;
        |  long double y;
        |  long double yo;""".stripMargin
    (new CGenerator(new CMonitorGenerator("metric")))(monitorExp, vars) shouldBe
      expectedMonitor(
        "(fmaxl((((curr.dxo)*(curr.dxo)) + ((curr.dyo)*(curr.dyo))) - ((params->V)*(params->V)), fminl(fmaxl(fmaxl(((0)) - (params->ep), ((0)) - (pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo) - (pre.xo), (pre.xo) - (curr.xo)), fmaxl((curr.yo) - (pre.yo), (pre.yo) - (curr.yo))), fmaxl((curr.dxo) - (curr.dxo), (curr.dxo) - (curr.dxo))), fmaxl((curr.dyo) - (curr.dyo), (curr.dyo) - (curr.dyo))), fmaxl((curr.x) - (pre.x), (pre.x) - (curr.x))), fmaxl((curr.y) - (pre.y), (pre.y) - (curr.y))), fmaxl((curr.dx) - (pre.dx), (pre.dx) - (curr.dx))), fmaxl((curr.dy) - (pre.dy), (pre.dy) - (curr.dy))), fmaxl((curr.v) - (pre.v), (pre.v) - (curr.v))), fmaxl((curr.w) - (pre.w), (pre.w) - (curr.w))), fmaxl((curr.a) - (-(params->B)), (-(params->B)) - (curr.a))), fmaxl((curr.r) - (pre.r), (pre.r) - (curr.r))), fmaxl(curr.t, ((0)) - (curr.t)))), fminl(fmaxl(fmaxl(pre.v, ((0)) - (pre.v)), fmaxl(fmaxl(((0)) - (params->ep), ((0)) - (pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo) - (pre.xo), (pre.xo) - (curr.xo)), fmaxl((curr.yo) - (pre.yo), (pre.yo) - (curr.yo))), fmaxl((curr.dxo) - (curr.dxo), (curr.dxo) - (curr.dxo))), fmaxl((curr.dyo) - (curr.dyo), (curr.dyo) - (curr.dyo))), fmaxl((curr.x) - (pre.x), (pre.x) - (curr.x))), fmaxl((curr.y) - (pre.y), (pre.y) - (curr.y))), fmaxl((curr.dx) - (pre.dx), (pre.dx) - (curr.dx))), fmaxl((curr.dy) - (pre.dy), (pre.dy) - (curr.dy))), fmaxl((curr.v) - (pre.v), (pre.v) - (curr.v))), fmaxl(curr.w, ((0)) - (curr.w))), fmaxl(curr.a, ((0)) - (curr.a))), fmaxl((curr.r) - (pre.r), (pre.r) - (curr.r))), fmaxl(curr.t, ((0)) - (curr.t))))), fmaxl(fmaxl((-(params->B)) - (curr.a), (curr.a) - (params->A)), fmaxl(fminl(((0)) - (curr.r), curr.r), fmaxl(fmaxl(((curr.w)*(curr.r)) - (pre.v), (pre.v) - ((curr.w)*(curr.r))), fmaxl(fminl(((((((pre.v)*(pre.v)))/(((2))*(params->B))) + (((params->V)*(pre.v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*((params->ep)*(params->ep))) + ((params->ep)*((pre.v) + (params->V)))))) - (fabsl((pre.x) + (-(curr.xo)))), ((((((pre.v)*(pre.v)))/(((2))*(params->B))) + (((params->V)*(pre.v))/(params->B))) + ((((params->A)/(params->B)) + ((1)))*((((params->A)/((2)))*((params->ep)*(params->ep))) + ((params->ep)*((pre.v) + (params->V)))))) - (fabsl((pre.y) + (-(curr.yo))))), fmaxl(fmaxl(((0)) - (params->ep), ((0)) - (pre.v)), fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl(fmaxl((curr.xo) - (curr.xo), (curr.xo) - (curr.xo)), fmaxl((curr.yo) - (curr.yo), (curr.yo) - (curr.yo))), fmaxl((curr.dxo) - (curr.dxo), (curr.dxo) - (curr.dxo))), fmaxl((curr.dyo) - (curr.dyo), (curr.dyo) - (curr.dyo))), fmaxl((curr.x) - (pre.x), (pre.x) - (curr.x))), fmaxl((curr.y) - (pre.y), (pre.y) - (curr.y))), fmaxl((curr.dx) - (pre.dx), (pre.dx) - (curr.dx))), fmaxl((curr.dy) - (pre.dy), (pre.dy) - (curr.dy))), fmaxl((curr.v) - (pre.v), (pre.v) - (curr.v))), fmaxl((curr.w) - (curr.w), (curr.w) - (curr.w))), fmaxl((curr.a) - (curr.a), (curr.a) - (curr.a))), fmaxl((curr.r) - (curr.r), (curr.r) - (curr.r))), fmaxl(curr.t, ((0)) - (curr.t))))))))))))<((0))",
        paramDecls, stateDecls, "",
        "metric")
  }

  it should "generate C code for passivesafetyabs with KeYmaeraX command line interface" taggedAs IgnoreInBuildTest in {
    // command line main has to initialize the prover itself, so dispose all test setup first
//    afterEach()

    val inputFileName = "./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.kym"
    val outputFileName = File.createTempFile("passivesafetyabs", ".c").getAbsolutePath

    KeYmaeraX.main(Array("-codegen", inputFileName, "-vars", "a,w,r,xo,yo,dxo,dyo", "-nointerval", "-out", outputFileName))

    val expectedCCode = scala.io.Source.fromFile("./keymaerax-webui/src/test/resources/examples/casestudies/robix/passivesafetyabs.c").mkString
    val actualFileContent = scala.io.Source.fromFile(outputFileName).mkString

    actualFileContent should include (expectedCCode)
  }

  it should "generate C code for passiveorientationsafety" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passiveorientationsafety.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double A;
        |  long double V;
        |  long double alpha;
        |  long double b;
        |  long double ep;
        |  long double v;
        |  long double x;
        |  long double y;""".stripMargin
    val stateDecls =
      """long double a;
        |  long double dx;
        |  long double dy;
        |  long double isVisible;
        |  long double odx;
        |  long double ody;
        |  long double ox;
        |  long double oy;
        |  long double r;
        |  long double t;
        |  long double talpha;
        |  long double w;""".stripMargin
    (new CGenerator(new CMonitorGenerator()))(monitorExp,
      Set(Variable("a"), Variable("w"), Variable("dx"), Variable("dy"), Variable("r"), Variable("t"), Variable("ox"),
           Variable("oy"), Variable("odx"), Variable("ody"), Variable("isVisible"),
           Variable("talpha"))) shouldBe
      expectedMonitor(
        "(((((curr.odx)*(curr.odx))) + (((curr.ody)*(curr.ody))))<=(((params->V)*(params->V))))&&(((((curr.w)*(pre.r))==(params->v))&&(((curr.a)==(-(params->b)))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(pre.r))&&(((curr.t)==((0)))&&(((curr.ox)==(pre.ox))&&(((curr.oy)==(pre.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(pre.isVisible))&&((curr.talpha)==(pre.talpha))))))))))))))||((((params->v)==((0)))&&((((curr.w)*(pre.r))==(params->v))&&(((curr.a)==((0)))&&(((curr.w)==(curr.w))&&(((curr.dx)==(-(pre.dx)))&&(((curr.dy)==(-(pre.dy)))&&(((curr.r)==(pre.r))&&(((curr.t)==((0)))&&(((curr.ox)==(pre.ox))&&(((curr.oy)==(pre.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(pre.isVisible))&&((curr.talpha)==(pre.talpha)))))))))))))))||(((-(params->b))<=(curr.a))&&(((curr.a)<=(params->A))&&(((curr.r)!=((0)))&&(((((params->v) + ((curr.a)*(params->ep)))<((0)))&&((((curr.isVisible)<((0)))||((((!(((params->x) - (curr.ox))>=((0))))||(((params->x) - (curr.ox))>(((((params->v)*(params->v)))/(((-2))*(curr.a))) + ((params->V)*((params->v)/(-(curr.a)))))))&&((!(((params->x) - (curr.ox))<=((0))))||(((curr.ox) - (params->x))>(((((params->v)*(params->v)))/(((-2))*(curr.a))) + ((params->V)*((params->v)/(-(curr.a))))))))||(((!(((params->y) - (curr.oy))>=((0))))||(((params->y) - (curr.oy))>(((((params->v)*(params->v)))/(((-2))*(curr.a))) + ((params->V)*((params->v)/(-(curr.a)))))))&&((!(((params->y) - (curr.oy))<=((0))))||(((curr.oy) - (params->y))>(((((params->v)*(params->v)))/(((-2))*(curr.a))) + ((params->V)*((params->v)/(-(curr.a))))))))))&&(((!((curr.r)>=((0))))||(((((params->v)*(params->v)))/(((-2))*(curr.a)))<((params->alpha)*(curr.r))))&&(((!((curr.r)<((0))))||(((((params->v)*(params->v)))/(((-2))*(curr.a)))<(-((params->alpha)*(curr.r)))))&&((((curr.w)*(curr.r))==(params->v))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(curr.r))&&(((curr.t)==((0)))&&(((curr.ox)==(curr.ox))&&(((curr.oy)==(curr.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(curr.isVisible))&&((curr.talpha)==((0)))))))))))))))))))||((((params->v) + ((curr.a)*(params->ep)))>=((0)))&&((((curr.isVisible)<((0)))||((((!(((params->x) - (curr.ox))>=((0))))||(((params->x) - (curr.ox))>((((((params->v)*(params->v)))/(((2))*(params->b))) + ((params->V)*((params->v)/(params->b)))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V))))))))&&((!(((params->x) - (curr.ox))<=((0))))||(((curr.ox) - (params->x))>((((((params->v)*(params->v)))/(((2))*(params->b))) + ((params->V)*((params->v)/(params->b)))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V)))))))))||(((!(((params->y) - (curr.oy))>=((0))))||(((params->y) - (curr.oy))>((((((params->v)*(params->v)))/(((2))*(params->b))) + ((params->V)*((params->v)/(params->b)))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V))))))))&&((!(((params->y) - (curr.oy))<=((0))))||(((curr.oy) - (params->y))>((((((params->v)*(params->v)))/(((2))*(params->b))) + ((params->V)*((params->v)/(params->b)))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*((params->v) + (params->V)))))))))))&&(((!((curr.r)>=((0))))||((((((params->v)*(params->v)))/(((2))*(params->b))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*(params->v)))))<((params->alpha)*(curr.r))))&&(((!((curr.r)<((0))))||((((((params->v)*(params->v)))/(((2))*(params->b))) + ((((curr.a)/(params->b)) + ((1)))*((((curr.a)/((2)))*(((params->ep)*(params->ep)))) + ((params->ep)*(params->v)))))<(-((params->alpha)*(curr.r)))))&&((((curr.w)*(curr.r))==(params->v))&&(((curr.a)==(curr.a))&&(((curr.w)==(curr.w))&&(((curr.dx)==(pre.dx))&&(((curr.dy)==(pre.dy))&&(((curr.r)==(curr.r))&&(((curr.t)==((0)))&&(((curr.ox)==(curr.ox))&&(((curr.oy)==(curr.oy))&&(((curr.odx)==(curr.odx))&&(((curr.ody)==(curr.ody))&&(((curr.isVisible)==(curr.isVisible))&&((curr.talpha)==((0)))))))))))))))))))))))))",
        paramDecls, stateDecls)
  }

  "quadcopter" should "generate C code for hybridquadrotor" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/quadcopter/hybridquadrotor.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val paramDecls =
      """long double h;
        |  long double kd;
        |  long double kp;
        |  long double sqrkp;
        |  long double v;
        |  long double y;""".stripMargin
    val code = (new CGenerator(new CMonitorGenerator()))(monitorExp, Set(Variable("href")))
    code shouldBe expectedMonitor(
      "((params->h)>=(curr.href))&&(((curr.href)>((0)))&&(((((((params->kp)<((0)))&&(((params->v)==((0)))&&((curr.href)>=(params->h))))||((((params->kp)<((0)))&&(((params->v)>((0)))&&(((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))==((((2))*(curr.href))*(params->kp)))&&(((params->h)*(params->y))>(((params->h)*(params->kd)) + (((2))*(params->v)))))))||((((params->kp)<((0)))&&(((params->v)<((0)))&&(((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))==(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&(((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))>((0))))))||((((params->kp)>((0)))&&(((params->v)==((0)))&&((curr.href)==(params->h))))||((((params->kp)>((0)))&&(((params->v)>((0)))&&((((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))==((((2))*(curr.href))*(params->kp)))&&((((params->h)*(params->y))>(((params->h)*(params->kd)) + (((2))*(params->v))))&&(((params->kd) + (((2))*(params->sqrkp)))<=((0)))))||((((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))==((((2))*(curr.href))*(params->kp)))&&((((params->kd) + (((2))*(params->sqrkp)))<((0)))&&(((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<((0)))))||((((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))==(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&((((params->kd) + (((2))*(params->sqrkp)))<((0)))&&(((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<((0)))))||(((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))==((((2))*(curr.href))*(params->kp)))&&(((params->kd)>(((2))*(params->sqrkp)))&&((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))>((0)))&&(((params->h)*(params->y))>=(((params->h)*(params->kd)) + (((2))*(params->v))))))))))))||(((params->kp)>((0)))&&(((params->v)<((0)))&&((((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))==((((2))*(curr.href))*(params->kp)))&&(((params->kd)>(((2))*(params->sqrkp)))&&(((params->h)*(params->y))<(((params->h)*(params->kd)) + (((2))*(params->v))))))||((((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))==(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&(((params->kd)>=(((2))*(params->sqrkp)))&&(((params->h)*(params->y))<(((params->h)*(params->kd)) + (((2))*(params->v))))))||((((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))==(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&(((params->kd)>(((2))*(params->sqrkp)))&&((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))>((0)))&&(((params->h)*(params->y))>=(((params->h)*(params->kd)) + (((2))*(params->v)))))))||(((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))==(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&((((params->h)*(params->y))>(((params->h)*(params->kd)) + (((2))*(params->v))))&&((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))>=((0)))&&(((params->kd) + (((2))*(params->sqrkp)))<((0))))))))))))))))&&((((((params->y)*(params->y)))==((((params->kd)*(params->kd))) - (((4))*(params->kp))))&&((params->y)>=((0))))&&((((((params->sqrkp)*(params->sqrkp)))==(params->kp))&&((params->sqrkp)>=((0))))&&((((((((((params->h)*(params->h)))*(((params->kp)*(params->kp)))) - (((((2))*(params->h))*(curr.href))*(((params->kp)*(params->kp))))) + ((((curr.href)*(curr.href)))*(((params->kp)*(params->kp))))) + ((((params->h)*(params->kd))*(params->kp))*(params->v))) - ((((curr.href)*(params->kd))*(params->kp))*(params->v))) + ((params->kp)*(((params->v)*(params->v)))))!=((0))))))||(((((params->kp)<((0)))&&(((params->v)==((0)))&&((((params->h)*(params->y))<=((params->h)*(params->kd)))||((((params->h)*((params->kd) + (params->y)))<=((0)))||((params->h)>(curr.href))))))||((((params->kp)<((0)))&&(((params->v)<((0)))&&((((params->h)*(params->y))<=(((params->h)*(params->kd)) + (((2))*(params->v))))||((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<=((0)))||((((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v)))!=(((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y))))))))||((((params->kp)<((0)))&&(((params->v)>((0)))&&((((params->h)*(params->y))<=(((params->h)*(params->kd)) + (((2))*(params->v))))||((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<=((0)))||((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))!=((((2))*(curr.href))*(params->kp)))))))||((((params->kp)>((0)))&&(((params->v)==((0)))&&((((params->h)!=(curr.href))&&((((params->kd)>=(((2))*(params->sqrkp)))&&(((params->h)*(params->y))>=((params->h)*(params->kd))))||((((params->h)*((params->kd) + (params->y)))>=((0)))&&(((params->kd) + (((2))*(params->sqrkp)))<((0))))))||((((params->kd)==(((2))*(params->sqrkp)))&&(((params->h)*(params->y))>=((params->h)*(params->kd))))||((((params->kd)<(((2))*(params->sqrkp)))&&(((params->kd) + (((2))*(params->sqrkp)))>((0))))||(((params->h)>(curr.href))||((((params->kd)>(((2))*(params->sqrkp)))&&(((params->h)*((params->kd) + (params->y)))<=((0))))||((((params->kd) + (((2))*(params->sqrkp)))<=((0)))&&(((params->h)*(params->y))<=((params->h)*(params->kd)))))))))))||((((params->kp)>((0)))&&(((params->v)<((0)))&&((((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))!=(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&((((params->h)*(params->y))>=(((params->h)*(params->kd)) + (((2))*(params->v))))||((params->kd)<=(((2))*(params->sqrkp)))))||(((params->kd)<(((2))*(params->sqrkp)))||((((params->kd)>(((2))*(params->sqrkp)))&&(((((params->h)*(params->y))<(((params->h)*(params->kd)) + (((2))*(params->v))))&&((((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))<(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))<((((2))*(curr.href))*(params->kp))))||(((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))>(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))||((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))>((((2))*(curr.href))*(params->kp))))))||(((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<=((0)))))||(((((params->h)*(params->y))>=(((params->h)*(params->kd)) + (((2))*(params->v))))&&((params->kd)<=(((2))*(params->sqrkp))))||(((params->kd) + (((2))*(params->sqrkp)))<=((0)))))))))||(((params->kp)>((0)))&&(((params->v)>((0)))&&((((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))!=((((2))*(curr.href))*(params->kp)))&&((((params->kd) + (((2))*(params->sqrkp)))>=((0)))||(((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))>=((0)))))||(((params->kd)>=(((2))*(params->sqrkp)))||(((((params->kd) + (((2))*(params->sqrkp)))<((0)))&&((((((2))*(params->v)) + ((params->h)*((params->kd) + (params->y))))<((0)))&&(((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))<(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))||(((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))<((((2))*(curr.href))*(params->kp)))||(((((((2))*(curr.href))*(params->kp)) + ((params->v)*(params->y)))>(((((2))*(params->h))*(params->kp)) + ((params->kd)*(params->v))))&&((((((2))*(params->h))*(params->kp)) + ((params->v)*((params->kd) + (params->y))))>((((2))*(curr.href))*(params->kp))))))))||((((params->kd) + (((2))*(params->sqrkp)))>((0)))||(((params->h)*(params->y))<=(((params->h)*(params->kd)) + (((2))*(params->v)))))))))))))))&&(((((params->y)*(params->y)))==((((params->kd)*(params->kd))) - (((4))*(params->kp))))&&(((params->y)>=((0)))&&(((((params->sqrkp)*(params->sqrkp)))==(params->kp))&&(((params->sqrkp)>=((0)))&&((((((((((params->h)*(params->h)))*(((params->kp)*(params->kp)))) - (((((2))*(params->h))*(curr.href))*(((params->kp)*(params->kp))))) + ((((curr.href)*(curr.href)))*(((params->kp)*(params->kp))))) + ((((params->h)*(params->kd))*(params->kp))*(params->v))) - ((((curr.href)*(params->kd))*(params->kp))*(params->v))) + ((params->kp)*(((params->v)*(params->v)))))==((0)))))))))&&((curr.href)==(curr.href))))",
      paramDecls, "long double href;")
    CodeGenTestTools.compileC(CodeGenTestTools.augmentMonitorMain(code, hasParams=true, hasInputs=false))
  }

  "Compiled controller monitor" should "evaluate boolean correctly" in {
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = KeYmaeraXParser(io.Source.fromInputStream(inputFile).mkString)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val monitorCode = (new CGenerator(new CMonitorGenerator()))(monitorExp, vars)

    // robot and obstacle drive straight towards each other
    val code =
      s"""
        |#include <stdio.h>
        |$monitorCode
        |
        |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
        |state fallback(state curr, const parameters* const params, const input* const in) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
        |
        |int main() {
        |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
        |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
        |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, &params, (const input* const)0, &ctrl, &fallback).a);
        |  /* jump robot ahead and speed up, now unsafe */
        |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
        |  printf("Returned a=%1.1Lf", monitoredCtrl(next, &params, (const input* const)0, &ctrl, &fallback).a);
        |  return 0;
        |}
        |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  it should "evaluate metric correctly" ignore withMathematica { _ =>
    //@todo mixed open/closed can evaluate to false at the boundary (e.g., x<=5 | x>6 turns into min(x-5,6-x)<0 == false for x=5)
    //      which is especially problematic when monitor contains equalities, e.g., x=5 | x>6
    val inputFile = getClass.getResourceAsStream("/examples/casestudies/robix/passivesafetyabs.kym")
    val monitorExp = ModelPlex.toMetric(io.Source.fromInputStream(inputFile).mkString.asFormula)
    val vars =
      Set(Variable("a"),Variable("dx"),Variable("dy"),Variable("r"),Variable("v"),Variable("w"),Variable("x"),Variable("y"),
        Variable("xo"),Variable("yo"),Variable("dxo"),Variable("dyo"),Variable("t"))
    val monitorCode = (new CGenerator(new CMonitorGenerator(kind="metric")))(monitorExp, vars)

    // robot and obstacle drive straight towards each other
    val code =
      s"""
         |#include <stdio.h>
         |$monitorCode
         |
         |state ctrl(state curr, parameters params, input input) { printf("Controller chooses A\\n"); curr.a = params->A; return curr; }
         |state fallback(state curr, parameters params, input input) { printf("Fallback returns -B\\n"); curr.a = -params->B; return curr; }
         |
         |int main() {
         |  state current = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=1.0, .w=1.0, .x=0.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0, .t=0.0 };
         |  parameters params = { .A=1.0, .B=2.0, .V=1.0, .ep=0.05 };
         |  state input = { 0 };
         |  printf("Returned a=%1.1Lf\\n", monitoredCtrl(current, params, input, &ctrl, &fallback).a);
         |  /* jump robot ahead and speed up, now unsafe */
         |  state next = { .a=0.0, .dx=1.0, .dy=0.0, .r=1.0, .v=4.0, .w=4.0, .x=9.0, .y=0.0, .xo=10.0, .yo=0.0, .dxo=-1.0, .dyo=0.0 };
         |  printf("Returned a=%1.1Lf", monitoredCtrl(next, params, input, &ctrl, &fallback).a);
         |  return 0;
         |}
         |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Controller chooses A\nReturned a=1.0\nController chooses A\nFallback returns -B\nReturned a=-2.0"
    }
  }

  "Controller generation" should "translate a simple deterministic controller" in {
    val ctrlPrg = "x:=2;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = (2); prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate a nondeterministic assignment into an input lookup" in {
    val ctrlPrg = "x:=*;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  prg.state.x = in->x; prg.success = 1;
        |  return prg.state;
        |}""".stripMargin
  }

  it should "translate sequential compositions, tests, and nondeterministic choices" in {
    val ctrlPrg = "x:=*;?x<=5; ++ x:=7;".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  {
        |    {
        |      prg.state.x = in->x; prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = (prg.state.x)<=((5));
        |    }
        |  }
        |  if (!prg.success) {
        |    prg.state.x = (7); prg.success = 1;
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "skip ODEs and repeat loops until success" in {
    val ctrlPrg = "{x:=2;{x'=4}}*".asProgram
    val cPrg = new CControllerGenerator()(ctrlPrg)
    cPrg shouldBe
      """state ctrlStep(state curr, const parameters* const params, const input* const in) {
        |  struct { state state; int success; } prg = { .state=curr, .success=0 };
        |  while (!prg.success) {
        |    {
        |      prg.state.x = (2); prg.success = 1;
        |    }
        |    if (prg.success) {
        |      prg.success = 1; /* done choosing actuator set values */
        |    }
        |  }
        |  return prg.state;
        |}""".stripMargin
  }

  it should "compile and run a controller" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val code = (new CGenerator(new CControllerGenerator()))(ctrlPrg, Set(Variable("x")))

    val mainCode =
      s"""
       |#include <stdio.h>
       |$code
       |
       |int main() {
       |  state current = { .x=0.0 };
       |  parameters params = { .A=1.0 };
       |  input in = { .x=0.5 };
       |  printf("Returned x=%1.1Lf\\n", ctrlStep(current, &params, &in).x);
       |  /* change input */
       |  input nextIn = { .x=2.0 };
       |  printf("Returned x=%1.1Lf", ctrlStep(current, &params, &nextIn).x);
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(mainCode)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        "Returned x=0.5\nReturned x=7.0"
    }
  }

  it should "compile and run a fallback controller of a monitor" in {
    val ctrlPrg = "x:=*;?x<=A; ++ x:=7;".asProgram
    val monitor = "xpost()<=A | xpost()=7".asFormula // == controller monitor of ctrlPrg

    val stateVars = Set(Variable("x"))
    val params = Set[NamedSymbol](Variable("A"))
    val inputs = Set(Variable("x"))

    val declarations =
      CGenerator.printParameterDeclaration(params) + "\n" +
      CGenerator.printStateDeclaration(stateVars) + "\n" +
      CGenerator.printInputDeclaration(inputs)
    val fallbackCode = new CControllerGenerator()(ctrlPrg, stateVars)
    val monitorCode = new CMonitorGenerator()(monitor, stateVars)

    val code = s"""
       |#include <stdio.h>
       |${CGenerator.INCLUDE_STATEMENTS}
       |$declarations
       |$fallbackCode
       |$monitorCode
       |
       |state ctrl(state curr, const parameters* const params, const input* const in) { printf("Choosing 2*%1.1Lf", curr.x); curr.x = 2*curr.x; return curr; }
       |
       |int main() {
       |  state current = { .x=0.2 };
       |  parameters params = { .A=1.0 };
       |  long double inputSequence[5] = { 3.0, 3.0, 3.0, 1.0, 0.5 };
       |  for (int i=0; i<5; ++i) {
       |    input in = { .x=inputSequence[i] };
       |    current = monitoredCtrl(current, &params, &in, &ctrl, &ctrlStep);
       |    printf(", result x=%1.1Lf\\n", current.x);
       |  }
       |  return 0;
       |}
       |""".stripMargin

    val cmd = CodeGenTestTools.compileC(code)
    val p = Runtime.getRuntime.exec(cmd)
    withClue(scala.io.Source.fromInputStream(p.getErrorStream).mkString) {
      p.waitFor() shouldBe 0
      scala.io.Source.fromInputStream(p.getInputStream).mkString shouldBe
        """Choosing 2*0.2, result x=0.4
          |Choosing 2*0.4, result x=0.8
          |Choosing 2*0.8, result x=7.0
          |Choosing 2*7.0, result x=1.0
          |Choosing 2*1.0, result x=0.5
          |""".stripMargin
    }
  }
}
